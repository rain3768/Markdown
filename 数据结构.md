# 第1章 绪论

## 一、研究问题

数学模型和非数学模型（主要是线性表、树、图结构）

## 二、基础概念和术语

### 1.数据

客观事物的符号表示，所有能输入到计算机并能被计算机处理的符号的总称。

### 2.数据元素

数据基础单位，被作为一个整体考虑和处理。

### 3.数据项

最小单位，不可分割，有独立含义，组成数据元素。

### 4.数据对象

数据子集，性质相同元素集合。

### 5.数据结构

相互之间存在一种或多种特定关系的数据元素的集合。

#### (1)、逻辑结构

##### 两要素

数据元素和关系；

##### 分类

集合结构，树结构，图结构和网状结构，（前三种被称为非线性结构）线性结构

线性结构：线性表：一般线性表（线性表）、特殊线性表（栈与队列、字符串）、线性表的推广（数组、广义表）

非线性结构：树结构（树和二叉树）、图结构（有向和无向）、集合结构

#### (2)、存储结构

顺序存储结构、链式存储结构

#### (3)、数据类型和抽象数据类型

数据类型

抽象数据类型(ADT)：用户定义的、表示应用问题的数学模型以及定义在这个模型上的一组操作的总称。

```c
ADT 抽象数据类型名{
	数据对象:<数据对象的定义>
	数据关系:<数据关系的定义>
	基本操作:<基本操作的定义>
}ADT 抽象数据类型名
    
基本操作(参数表)
{
    初始条件:<初始条件描述>
    操作结果:<操作结果描述>
}
```

基础操作有两种参数：赋值结果只为操作提供输入值；引用参数以“&”打头，处可提供输入值外，还将返回操作结果。

## 三、算法和算法分析

### 1.算法的定义及特性

**算法**是为了解决某类问题而规定的一个有限长的操作序列。

（1）有穷性

（2）确定性

（3）可行性

（4）输入

（5）输出

### 2.评价算法优劣的基本标准

（1）正确性

（2）可读性

（3）健壮性：当输入非法数据事，做出正确反应或适当处理。

（4）高效性：包括时间和空间两方面。

### 3.时间复杂度

#### （1）问题规模和语句频度

**问题规模**：算法求解问题输入量的多少，是问题大小的本质表示，一般用整数$n$表示。

**语句频度**：一句语句的重复执行次数。

#### （2）时间复杂度定义

$$
T(n)=O(f(n))
$$

它表示随问题规模$n$增大，算法执行时间的增长率和$f(n)$的增长率相同，称作算法的**渐变时间复杂度**，简称**时间复杂度**。

#### （3）举例计算

##### 常量阶

```c
{x++;s=0;}
```

两条语句频度为1，算法的执行时间与问题规模$n$无关，是个常数，所以时间复杂度为$T(n)=O(1)$，成为常量阶。

##### 线性阶

```c
for(i=0;i<n;i++){x++;s=0;}
```

循环体内两条基本语句频度均为$f(n)=n$，所以算法时间复杂度为$T(n)=O(n)$，称为线性阶。

##### 平方阶

```c
x=0;y=0;
for(k=1;k<n;k++)
	x++;
for(i=1;i<n;i++)
    for(j=1;j<n;j++)
        y++;
```

对循环语句只需要考虑循环体中语句的执行次数，以上程序段中频度最大的语句是(6)，其频度为$f(n)=n^2$，所以该算法的时间复杂度为$T(n)=O(n^2)$，称为平方阶。

##### 对数阶

```c
for(i=1;i<n;i*=2)
{
	x++;
	s=0;
}
```

算法时间复杂度为$T(n)=O(\log_2 n)$。

常见时间复杂度按数量级递增排列依次为：常数阶、对数阶、线性阶、线性对数阶、平方阶、……、$k$次方阶、指数阶等。

#### （4）最好、最坏和平均时间复杂度

称算法最好情况下的时间复杂度为**最好时间复杂度**（计算量最小值），称算法最好情况下的时间复杂度为**最坏时间复杂度**（计算量最大值）。

算法的**平均时间复杂度**是指算法在所有可能情况下，按照输入实例一等概率出现时，算法计算量的加权平均值。

### 4.空间复杂度

$$
S(n)=O(f(n))
$$

##### 示例

```c
for(i=0;i<n/2;i++)
{
	t=a[i];
    a[i]=a[n-1-i];
    a[n-1-i]=t;
}
```

需要借助一个变量$t$，与问题规模$n$大小无关，所以空间复杂度为$O(1)$。

```c
for(i=0;i<n;i++)
    b[i]=a[n-1-i];
for(i=o;i<n;i++)
    a[i]=b[i];
```

需要另外借助一个大小为$n$的辅助数组$b$，所以空间复杂度为$O(n)$。

# 第2章 线性表

## 一、线性表的顺序储存表示

**顺序表**：用一组地址连续的储存单元一次储存表的数据元素。特点是逻辑上相邻的数据元素，其物理次序也是相邻的，是一种随机存取的储存结构。

```c
//-----顺序表的存储结构-----
#define MAXSIZE 100
typedef struct
{
    ElemType *elem;						//储存空间的基地址
    int length; 						//当前长度
}SqList;								//顺序表的结构类型为SqList
//ElemType是为了统一描述而自定的，根据实际为具体的数据类型。
```

## 二、基本操作实现

### 1.初始化

```c
Status InitList(SqList &L)
{//构造一个空的顺序表L
	L.elem=new ElemType[MAXSIZE];		//为顺序表分配一个大小为MAXSIZE的数组空间
    if(!L.elem) exit(OVERFLOW); 		//储存分配失败退出
    L.length=0;							//空表长度为0
    return OK;
}
```

其时间复杂度为$O(1)$。

### 2.取值

```c
Status GetElem(SqList L,int i,ElemType &e)
{
	if(i<1||i>L.length) return ERROR; 	 //判断i值是否合理，若不合理，返回ERROR
    e=L.elem[i-1];					 	 //elem[i-1]单元存储第i个数据元素
	return OK;
}
```

其时间复杂度为$O(1)$。

### 3.查找

```c
int LocateElem(SqList L,ElemType e)
{//在顺序表L中查找值为e的数据元素，返回其序号
    for(i=0;i<L.length;i++)
  		if(L.elem[i]==e) return i+1; 	//查找成功，返回序号i+1
	return 0;						 	//查找失败，返回0
}
```

在查找时，未确定元素在顺序表中的位置，需和给定值进行比较的数据元素个数的期望值称为查找算法在查找成功时的**平均查找长度**。

假设$p_i$是查找第$i$个元素的概率，$C_i$为找到表中其关键字与给定值相等的第$i$个记录时，和给定值已经进行过比较的关键字个数，则在长度为$n$的线性表中，查找成功时的平均查找长度为
$$
ASL=\sum_{i=1}^n p_iC_i
$$
其时间复杂度为$O(n)$。

### 4.插入

```c
Status ListInsert(SqList &L,int i,ElemType e)
{//在顺序表L中第i个位置插入新的元素e，i值的合法范围为1≤i≤L.length+1
	if((i<1)||(i>L.length+1)) return ERROR;//i值不合法
 	if(L.length==MAXSIZE) return ERROR;	   //储存空间已满
    for(j=L.length-1;j>=i-1;j--)
        L.elem[j+1]=L.elem[j];			   //插入位置及之后的元素后移
    L.elem[i-1]=e;						   //将新元素e放入第i个位置
    ++L.length;  						   //表长加一
    return OK;
}
```

其时间复杂度为$O(n)$。

### 5.删除

```c
Status ListDelete(SqList &L,int i)
{//在顺序表L中删除第i个元素，i值的合法范围是1≤i≤L.length
    if((i<1)||(i>L.length)) return ERROR;   //i值不合法
	for(j=i;j<=L.length-1;j++)
        L.elem[j-1]=L.elem[j];				//被删除元素之后的元素前移
    --L.length;								//表长减1
    return OK;
}
```

其时间复杂度为$O(n)$。

## 三、单链表

### 1.定义

**特点**：用一组任意的储存单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的。）

元素$a_i$：存储本身信息，存储一个指示其直接后继的信息（即直接后继的存储位置）。

**结点**（node）：这两部分信息组成数据元素$a_i$的存储映像。

**两个域**：**数据域**：其存储数据元素信息的域；**指针域**：存储直接后继存储位置的域。

指针域中存储的信息称作**指针**或**链**。$n$个结点（$a_i(a\leq i\leq n)$的储存映像）链结成一个**链表**。

```c
//——————单链表的存储结构——————
typedef struct  LNode
{
	ElemType data;							  //结点的数据域
    struct LNode *next;						  //结点的指针域
}LNode,*LinkList;							  //LinkList为指向结构体LNode的指针												  类型
```

**头结点**:在单链表的第一个结点之前附设一个结点，其指针域指向首元结点。

**首元结点**：链表中储存第一个数据元素$a_1$的结点。

**头指针**：指向链表中第一个结点的指针。若链表设有头指针，则头指针所指结点为线性表的头结点；若没有，则头指针指结点为该线性表的首元结点。

**作用**：（1）便于首元结点的处理；（2）便于空表和非空表的统一处理。

单链表是非随机存取的储存结构，要去的第$i$个数据元素必须从头指针出发顺链寻找，也成为**顺序存取**的存取结构。

### 2.操作

#### （1）初始化

```c
Status InitList(LinkList &L)
{//构造一个空的单链表L
	L=new LNode;								//生成新的结点作为头结点，用头指针L													 指向头结点
    L->next=NULL;								//头结点的指针域为空
    return OK;
}
```



#### （2）取值

```c
Status GetElem(LinkList L,int i,ElemType &e)
{//在带头结点的单链表L中根据序号i获取元素的值，用e返回L中第i个数据元素的值
	p=L->next;j=1;								//初始化，p指向首元结点，计数器j初													 值赋1
    while(p&&j<i)								//顺链域向后扫描，知道p为空或p指向													 第i个元素
    {
        p=p->next;								//p指向下一个结点
        ++j;									//计数器j相应加1
    }
    if(!p||j>i) return ERROR;					//i值不合法i>n或i≤0
    e=p->data;									//取第i个结点的数据域
    return OK;
}
```

时间复杂度为$O(n)$。

#### （3）按值查找

```c
LNode *LocateElem(LinkList L,ElemType e)
{//在带头结点的单链表L中查找值为e的元素
    p=L->next;									 //初始化，p指向首元结点
	while(p && p->data!=e)						 //顺链域向后扫描，直到p为空或p所													   指结点的数据等于e
        p=p->next;								 //p指向下一个节点
    return p;									 //查找成功返回值为e的结点地址p，													   查找失败p为NULL
}
```

时间复杂度为$O(n)$。

#### （4）插入

```c
Status ListInsert(LinkList &L,int i,ElemType e)
{//在带头结点的单链表L中第i个位置插入值为e的新结点
    p=L;j=0;
    while(P && (j<i-1))
    	{p=p->next;++j;}						//查找第i-1个结点，p指向该结点
	if(!p||j>i-1) return ERROR;					//i>n+1或者i<1
	s=new LNode;								//生成新结点*s
    s->data=e;									//将结点*s的数据域置为e
    s->next=p->next;							//将结点*s的指针域指向结点a
    p->next=s;									//将结点*p的指针域指向结点*s
    return OK;
}
```

时间复杂度为$O(n)$。

#### （5）删除

```c
Status ListDelete(LinkList &L,int i)
{//在带头结点的单链表L中，删除第i个元素
    p=L;j=0;
    while((p->next) && (j<i-1))					 //查找第i-1个结点，p指向该结点
    	{p=p->next;++j;}
    if(!(p->next)||(j>i-1))	return ERROR;		 //当i>n或i<1时，删除位置不合理
    q=p->next;									 //临时保存被删结点的地址已被释放
    p->next=q->next;							 //改变删除结点前驱结点的指针域
	delete q;									 //释放被删除结点的空间
    return OK;
}
```

时间复杂度为$O(n)$。

#### （6）创建单链表

##### 前插法

```c
void CreateList_H(LinkList &L,int n)
{//逆位序输入n个元素的值，建立带表头结点的单链表L
    L=new LNode;
    L->next=NULL;								  //先建立一个带头结点的空链表
    for(i=0;i<n;i++)
    {
		p=new LNode;							  //生成新结点*p
        cin>>p->data;							  //输入元素赋给新结点*p的数据域
        p->next=L->next;L->next=p;				  //将新结点*p插入到头结点之后
    }
	
}//cin>>相当于输入scanf
```

时间复杂度为$O(n)$。

##### 后插法

```c
void CreatList_R(LinkList &L,int n)
{//正位序输入n个元素的值，建立带表头结点的单链表L
    L=new LNode;
    L->next=NULL;								   //先建立一个带头结点的空链表
    r=L;										   //尾指针r指向头结点
    for(i=0;i<n;i++)
    {
		p=new LNode;							   //生成新结点
        cin>>p->data;							   //输入元素值赋给新节点*p的数据域
        p->next=NULL;r->next=p;					   //将新结点*p插入尾结点*r之后
        r=p;									   //r指向新的尾结点*p
    }
}
```

### 3.循环链表

**特点**：表最后一个结点的指针域指向头结点。

```c
// 终止判别
p!=L||p->next!=L;
```

**两个链表合并**

```c
p=B->next->next;
B->next=A->next;
A->next=p;
```

### 4.双向链表

**双向链表**：有两个指针域，一个指向直接后继，另一个指向直接前驱。

```c
//------双向链表的存储结构------
typedef struct DuLNode
{
	ElemType data;									//数据域
    struct DuLNode *prior;							//指向直接前驱
    struct DuLNode *next;							//指向直接后继
}DuLNode，*DuLinkList;
```

#### 操作

##### 插入

```c
Status Listinsert_DuL(DuLinkList &L,int i,ElemType e)//插入的结点为*s，原位置结点为*p
{//在带头结点的双向链表L中第i个位置之前插入元素e
    if(!(p=GetElem_DuL(L,i)))					   //在L中确定第i个元素的位置指针p
        return ERROR;							   //p为NULL时，第i个元素不存在
	s=new DuLNode;								   //生成新结点
    s->data=e;									   //将结点*s的数据域置为e
    s->prior=p->prior;							   //将结点*s插入L中
    p->prior->next=s;							   //让结点*p前的结点的直接后继指针域指向结点*p
    s->next=p;									   //让结点*s的后继指针域指向结点*p
    p->prior=s;									   //让结点*p的前驱指针域指向结点*s
    return OK;
}
```

其时间复杂度为$O(1)$ 。

##### 删除

```c
Status ListDelete_DuL(DuLinkList &L,int i)
{//删除带头结点的双向链表L中的第i个元素
    if(!(p=GetElem_DuL(L,i)))						//在L中确定第i元素的位置指针p
        return ERROR;								//p为NULL时，第i个元素不存在
    p->prior->next=p->next;							//修改被删结点的前驱结点的后继指针
    p->next->prior=p->prior;						//修改被删结点的后继结点的前驱指针
    delete p;										//释放被删结点的空间
    return OK;
}
```

其时间复杂度为$O(1)$ 。

### 5.线性表应用

#### （1）线性表合并

```c
void MergeList(List &LA,List LB)
{//将所有的线性表LB中但不在LA中的数据元素插入到LA中
	m=ListLength(LA); n=ListLength(LB);				//求线性表的长度
    for(i=1;i<=n;i++)
    {
        GetElem(LB,i,e);							//取LB中第i个数据元素赋给e
        if(!LocateElem(LA,e))						//LA中不存在和e相同的数据元素
            ListInsert(LA,++m,e);					//将e插在LA的最后
    }
}
```

其时间复杂度为$O(m\times n)$ 。

#### （2）顺序有序表

```c
void MergeList_Sq(SqList LA,SqList LB,SqList &LC)
{//已知顺序有序表LA和LB的元素按值非递减排列
 //归并LA和LB得到新的顺序有序表LC，LC的元素也按值非递减排列
    LC.length=LA.length+LB.length;					 //新表长度为待合并两表的长度之和
    LC.elem=new ElemType[LC.length];				 //为合并后的新表分配一个数组空间
    pc=LC.elem;										 //指针pc指向新表的第一个元素
    pa=LA.elem;	pa=LB.elem;							 //指针pa和pb的初值分别指向两个表的第一个元素
    pa_last=LA.elem+LA.length-1;					 //指针pa_last指向LA的最后一个元素
    pb_last=LB.elem+LB.length-1;					 //指针pa_last指向LB的最后一个元素
    while((pa<=pa_last)&&(pb<=pb_last))				 //LA和LB均为到达表尾
    {
		if(*pa<=*pb) *pc++=*pa++;					 //依次“摘取”两表中值较小的结点插入到LC的最后
        else *pc++=*pb++;
    }
	while(pa<=pa_last) *pc++=*pa++;					 //LB已到达表尾，依次将LA的剩余元素插入到LC的最后
    while(pb<=pb_last) *pc++=*pb++;					 //LA已到达表尾，依次将LB的剩余元素插入到LC的最后
}
```

时间复杂度和空间复杂度均为$O(m+n)$。

#### （3）链式有序表

```c
void MergeList_L(LinkList &LA,LinkList &LB,LinkList &LC)
{//已知单链表LA和LB的元素按值非递减排列
 //归并LA和LB的到新的单链表LC，LC的元素也按值非递减排列
    pa=LA->next;pb=LB->next;						  //pa和pb的初值分别指向两个表的第一个结点
    LC=LA;											  //用LA的头结点作为LC的头结点
    pc=LC;											  //pc的初值指向LC的头结点
    while(pa&&pb)
    {//LA和LB均为到达表尾，依次“摘取”两表中值较小的结点插入到LC的最后
        if(pa->data<=pb->data)						  //“摘取”pa所指结点
        {
            pc->next=pa;							  //将pa所指结点链接到pc所指结点之后
            pc=pa;									  //pc指向pa
            pa=pa->next;							  //pa指向下一个结点
        }
        else										  //“摘取”pb所指结点
        {
			pc->next=pb;							  //将pb所指结点链接到pc所指结点之后
            pc=pb;									  //pc指向pb
            pb=pb->next;							  //pb指向下一个结点
        }
    }												  //while
    pc->next=pa?pa:pb;								  //将非空表的剩余段插入到pc所指结点之后
    delete LB;										  //释放LB的头结点
}
```

时间复杂度为$O(m+n)$，空间复杂度为$O(1)$。没有开辟新的空间只是将原有结点，拆开打乱，组成一个新的链表。

#### （4）系数多项式的运算

其结构为

```c
typedef struct PNode
{
	float coef;											//系数
    int   expn;											//指针
    struct PNode *next;									//指针域
}PNode,*Polynomial;
```

##### a.多项式创建

```c
void CreatPolyn(Polynomial &p,int n)
{//输入n项的系数和指数，建立表示多项式的有序链表p
    P=new PNode;									   
    P->next=NULL;									   //先建立一个带头结点的单链表
    for(i=1;i<=n;++i)								   //依次输入n个非零项
    {
		s=new PNode;								   //生成新结点
        scanf("%f%d",&s.coef,&s.expn);				   //输入系数和指数
        pre=p;										   //pre用于保存q的前驱，初值为头结点
        q=P->next;									   //q初始化，指向首元结点
        while(q&&q->expn<s->expn)					   //通过比较指数找到第一个大于输入项指数的项*q
        {
            pre=q;
            q=p->next;
        }											   //while
        s->next=q;									   //将输入项s插入到q和其前驱结点pre之间
        pre->next=s;
    }												   //for
}
```

##### b.多项式相加

```c
void AddPolyn(Polynomial &Pa,Polynomial &Pb)
{//多项式加法：Pa=Pa+Pb，利用两个多项式的结构结点构成“和多项式”
	p1=Pa->next;p2=Pb->next;						   //p1和p2初值分别指向Pa和Pb的首元结点
    p3=Pa;											   //p3指向和多项式的当前结点，初值为Pa
    while(p1&&p2)									   //p1和p2均非空
    {
		if(p1->expn==p2->expn)						   //指数相等
        {
			sum=p1->coef+p2->coef;					   //sum保存两项的系数和
            if(sum!=0)								   //系数和不为0
            {
                p1->coef=sum;						   //修改Pa当前结点的系数值为两项系数的和
                p3->next=p1;p3=p1;					   //将修改后的Pa当前结点链在p3之后，p3指向p1
                p1=p1->next;						   //p1指向后一项
                r=p2;p2=p2->next;delete r;			   //删除Pb当前结点，p2指向后一项
            }
            else									   //系数和为0
        	{
            	r=p1;p1=p1->next;delete r;			   //删除Pa当前结点，p1指向后一项
            	r=p2;p2=p2->next;delete r;			   //删除Pb当前结点，p2指向后一项
        	}
        }
        else if(p1->expn<p2->expn)					   //Pa当前结点的指数值最小
        {
            p3->next=p1;							   //将p1链在p3之后
            p3=p1;									   //p3指向p1
            p1=p1->next;							   //p1指向后一项
        }
        else										   //Pb当前结点的指数值小
        {
            p3->next=p2;							   //将p2链在p3之后
            p3=p2;									   //p3指向p2
            p2=p2->next;							   //p2指向后一项
        }
    }												   //while
    p3->next=p1?p1:p2;								   //插入非控多项式的剩余段
    delete Pb;										   //释放Pb的头结点
}
```

时间复杂度为$O(m+n)$，空间复杂度为$O(1)$。 

# 第3章 栈和队列

## 一、定义

**栈**：限定仅在表尾进行插入或删除操作的线性表。（后进先出）

**栈顶**：表尾端；**栈底**：表头端

**队列**：是一种先进先出的线性表。

**队尾**：允许插入的一端；**队头**：允许删除的一端

## 二、顺序栈的表示和实现

### **顺序栈结构**

```c
//——————顺序栈的储存结构——————
#define MAXSIZE 100									    //顺序栈存储空间的初始分配量
typedef struct
{
	SElemType *base;									//栈底指针
	SElemType *top;										//栈顶指针
    int stacksize;										//栈可用的最大容量
}SqStack;
```

### 操作

#### 1.初始化

```c
Status InitStack(SqStack &s)
{//构造一个空栈S
    S.base=new SElemType[MAXSIZE];						//为顺序栈动态分配一个最大容量为MAXSIZE的数组空间
    if(!S.base)	exit(OVERFLOW);							//存储分配失败
    S.top=S.base;										//top初始为base，空栈
    S.stacksize=MAXSIZE;								//stacksize置为栈的最大容量stacksize
    return OK;
}
```

#### 2.入栈

```c
Status Push(SqStack &S,SElemType e)
{//插入元素e为新的栈顶元素
	if(S.top-S.base==S.stacksize)	return ERROR;		//栈满
    *S.top++=e;											//元素e压入栈顶，栈顶指针加1
    return OK;
}
```

#### 3.出栈

```c
Status Pop(SqStack &S,SElemType &e)
{//删除S的栈顶元素，用e返回其值
	if(S.top==S.base)	return ERROR;					//栈空
    e=*--S.top;											//栈顶指针减1，将栈顶元素赋给e
    return OK;	
}
```

#### 4.取栈顶元素

```c
SElemType GetTop(SqStack S)
{//返回S的栈顶元素，不修改栈顶指针
	if(S.top!=S.base)									//栈非空
        return *(S.top-1);								//返回栈顶元素的值，栈顶指针不变
}
```

### 注意

由于顺序栈和顺序表一样，受到最大空间容量的限制，因此在应用程序无法预先估计可能达到的最大容量时，还是应该使用下面介绍的链栈。

## 三、链栈的表示和实现

#### 定义

**链栈**：采用链式存储结构实现的栈。通常用单链表实现。

```c
//——————链栈的存储结构——————
typedef struct StackNode
{
	ElemType data;
    struct StackNode *next;
}StackNode,*linkStack;
```

以链表的头部作为栈顶是最方便的，而且不需要附加头结点。

#### 操作

##### 1.初始化

```c
Status InitStack(linkStack &s)
{//构造一个空栈S，栈顶指针置空
	S=NULL;
    return OK;
}
```

##### 2.入栈

```c
Status Push(LinkStack &S,SElemType e)
{//在栈顶插入元素e
    p=new StatckNode;									//生成新结点
    p->data=e;											//将新结点数据域置为e
    p->naxt=S;											//将新结点插入栈顶
	S=p;												//修改栈顶指针为p
    return OK;
}
```

##### 3.出栈

```c
Status Pop(LinkStack &S,SElemType &e)
{//删除S的栈顶元素，用e返回其值
    if(S==NULL)	return ERROR;							//栈空
    e=S->data;											//将栈顶元素赋给e
    p=S;												//用p临时保存栈顶元素空间，以备释放
    S=S->next;											//修改栈顶指针
    delete p;											//释放原栈顶元素的空间
    return OK;
}
```

##### 4.取栈顶元素

```c
SElemType GetTop(LinkStack S)
{//返回S的栈顶元素，不修改栈顶指针
    if(S!=NULL)											//栈非空
        return S->data;									//返回栈顶元素的值，栈顶指针不变
}
```

## 四、栈和递归

### 分治法

```c
void p()
{
	if(递归结束条件成立)可直接求解;							//递归终止的条件
    else p(较小的参数);									 //递归步骤
}
```

##### 应用分治法的问题条件

（1）能将一个问题转变成一个新的问题，而新问题与原问题的解法相同或类同，不同的仅是处理的对象，并且这些处理对象更小且更有规律。

（2）可以通过上述转化而使问题简化。

（3）必须有一个明确的递归出口，或称递归的边界。

## 五、队列的表示和实现

### 定义

队列也有两种储存方式，顺序表示和链式表示。

队列的**顺序存储结构**：

```c
//——————队列的顺序存储结构
#define MAXQSIZE 100									//队列可能达到的最大长度
typedef struct
{
	QElemType *base;									//存储空间的基地址
    int front;											//头指针
    int rear;											//尾指针
}SqQueue;
```

初始化时，令`front=rear=0`，每当插入新的队列尾元素时，尾指针rear增1；每当删除队列头元素时，头指针front加1。

因为队尾入队，队头出队，所以会造成假溢出。

为解决假溢出问题，所以利用“模”运算（`Q.rear=(Q.rear+1)%MAXQSIZE;`）来实现，称之为**循环列队**。

### 操作

#### 1.初始化

```c
Status InitQueue(SqQueue &Q)
{//构造一个空队列Q
    Q.base=new QElemType[MAXQSIZE];						//为队列分配一个最大空间为MAXQSIZE的数组空间
    if(!Q.base) exit(OVERFLOW);							//存储空间分配失败
	Q.front=Q.rear=0;									//头指针和尾指针位置为0，队列为空
    return OK;
}
```

#### 2.求队列长度

```c
int QueueLength(SqQueue Q)
{//返回Q的元素个数，即队列的长度
    return(Q.rear-Q.front+MAXQSIZE)%MAXQSIZE;
}
```

#### 3.入队

```c
Status EnQueue(SqQueue &Q,QElemType e)
{//插入元素e为Q的新的队列元素
    if((Q.rear+1)%MAXQSIZE==Q.front)					 //尾指针在循环意义上加1后等于头指针。表明队满
        return ERROR;
    Q.base[Q.rear]=e;									 //新元素插入队尾
    Q.rear=(Q.rear+1)%MAXQSZIE;							 //队尾指针加1
    return OK;											 
}
```

#### 4.出队

```c
Status DeQueue(SqQueue &Q,QElemType &e)
{//删除Q的队头元素，用e返回其值
    if(Q.front==Q.rear)	return ERROR;					 //队空
    e=Q.base[Q.front];									 //保存队友元素
    Q.front=(Q.front+1)%MAXQSIZE;						 //队头指针加一
    return OK;
}
```

#### 5.取队头元素

```c
QElemType GetHead(SqQueue Q)
{//返回的队头元素，不修改头指针
    if(Q.front!=Q.rear)									 //队列非空
		return Q.base[Q.front];							 //返回队头元素的值，队头指针不变
}
```

无法预测队列最大长度，则宜采用链对。

## 六、链队的表示和实现

### 定义

**存储结构**：

```c
//——————队列的链式存储结构——————
typedef struct QNode
{
	QElemType data;
    struct QNode *next;
}QNode,*QueuePtr;
typedef struct
{
    QueuePtr front;									    //队头指针
   	QueuePtr rear;										//队尾指针
}LinkQueue;
```

### 操作

#### 1.初始化

```c
Status InitQueue(LinkQueue &Q)
{//构造一个空队列Q
	Q.front=Q.rear=new QNode;							 //生成新的结点作为头结点，队头和队尾指针指向此结点
    Q.front->next=NULL;									 //头结点的指针域置空
    return Ok;
}
```

#### 2.入队

```c
Status EnQueue(LinkQueue &Q,QElemType e)
{//插入元素e为Q的新的队尾元素
	p=new QNode;										 //为入队元素分配结点空间，用指针p指向
    p->data=e;											 //将新结点数据域置为e
    p->next=NULL;Q.rear->next=p;						 //将新结点插入到队尾
    Q.rear=p;											 //修改队尾结点
    return OK;
}
```

#### 3.出队

```c
Status DeQueue(LinkQueue &Q,QElemType &e)
{//删除Q的队头元素，用e返回其值
    if(Q.front==Q.rear)	return ERROR;					//若队列空，则返回ERROR
    p=Q.front->next;									//p指向队头元素
    e=p->data;											//e保存队头元素的值
    Q.front->next=p->next;								//修改头结点的指针域
    if(Q.rear==p)	Q.rear=Q.front;						//最后一个元素被删，队尾指针指向头结点
    delete p;											//释放原队头元素的空间
    return OK;
}
```

#### 4.取队头元素

```c
QElemType GetHead(LinkQueue Q)
{//返回Q的队头元素，不修改队头指针
	if(Q.front!=Q.rear)									 //队列非空
        return Q.front->next->data;						 //返回队头元素的值，队头指针不变
}
```

## 七、案例

### 括号匹配的检验

#### 操作

```c
Status Matching() 
{//检验表达式中所含括号是否正确匹配，如果匹配，则返回true，否则返回false
 //表达式以“#”结束
	InitStack(S); 										//初始化空栈
	int flag = 1; 										//标记匹配结果以控制循环及返回结果
	ch=getchar();										//读入第一个字符
	while (ch != '#' && flag)							//假设表达式以“#”结尾
	{
		switch (ch) {
		case '[' :
		case '(': 										//若是左括号，则将其压入栈
			Push(S, ch);
			break;
		case ')': 										//若是“)”，则根据当前栈顶元素的值分情况考虑
			if (!StackEmpty(S) && GetTop(S) == '(')
				Pop(S, x); 								//若栈非空且栈顶元素是“(”，则正确匹配
			else
				flag = 0; 								//若栈空或栈顶元素不是“(”，则错误失败
			break;
		case ']': 										//若是“]”，则根据当前栈顶元素的值分情况考虑
			if (!StackEmpty(S) && GetTop(S) == '[')
				Pop(S, x); 								//若栈非空且栈顶元素是“[”，则正确匹配
			else
				flag = 0;								//若栈空或栈顶元素不是“[”，则错误匹配
			break;
		} 												//switch
		ch=getchar(); 									//继续读入下一个字符
	} 													//while
	if (StackEmpty(S) && flag) return true; 			//匹配成功
	else return false; 									//匹配失败
}
```

时间复杂度为$O(n)$，空间复杂度为$O(n)$。

### 表达式求值

#### 操作

```c
char EvaluateExpression() 
{//算术表达式求值的算符优先算法，设OPTR和OPND分别为运算符栈和操作数栈
	InitStack(OPND); 									//初始化OPND栈
	InitStack(OPTR); 									//初始化OPTR栈
	Push(OPTR, '#'); 									//将表达式起始符“#”压入OPTR栈
	cin >> ch;
	while (ch != '#' || (GetTop(OPTR) != '#')) 			//表达式没有扫描完毕或OPTR的栈顶元素不为“#”
	{
		if (!In(ch)) {
			Push(OPND, ch);
			ch=getchar();
		} 												//ch不是运算符则进OPND栈
		else
			switch (Precede(GetTop(OPTR), ch)) 			//比较OPTR的栈顶元素和ch的优先级
			{
			case '<':
				Push(OPTR, ch);
				ch=getchar(); 							//当前字符ch压入OPTR栈，读入下一字符ch
				break;
			case '>':
				Pop(OPTR, theta); 						//弹出OPTR栈顶的运算符
				Pop(OPND, b);
				Pop(OPND, a); 							//弹出OPND栈顶的两个运算数
				Push(OPND, Operate(a, theta, b)); 		//将运算结果压入OPND栈
				break;
			case '=': 									//OPTR的栈顶元素是“(”且ch是“)”
				Pop(OPTR, x);
				ch=getchar(); 							//弹出OPTR栈顶的“(”，读入下一字符ch
				break;
			} 											//switch
	} 													//while
	return GetTop(OPND);								//OPND栈顶元素即为表达式求值结果
}
```

时间复杂度为$O(n)$，空间复杂度为$O(n)$。

### 舞伴问题

#### 结构定义

```c
//- - - - - 跳舞者个人信息- - - - - 
typedef struct {
	char name[20]; 										//姓名
	char sex; 											//性别，'F'表示女性，'M'表示男性
} Person;

//- - - - - 队列的顺序存储结构- - - - - 
#define MAXQSIZE 100
typedef struct {
	Person *base; 										//队列中数据元素类型为Person
	int front; 											//头指针
	int rear; 											//尾指针
} SqQueue;

SqQueue Mdancers, Fdancers; 							//分别存放男士和女士入队者队列
```

#### 操作

```c
void DancePartner(Person dancer[], int num)
{//结构数组dancer中存放跳舞的男女，num是跳舞的人数。
	InitQueue(Mdancers); 								//男士队列初始化
	InitQueue(Fdancers); 								//女士队列初始化
	Person p;
	for (int i = 0; i < num; i++) 						//依次将跳舞者根据其性别入队
	{
		p = dancer[i];
		if (p.sex == 'F') EnQueue(Fdancers, p); 		//插入女队
		else EnQueue(Mdancers, p); 						//插入男队
	}
	printf("The dancing partners are:\n");
	while (!QueueEmpty(Fdancers) && !QueueEmpty(Mdancers)) 
    {//依次输出男女舞伴的姓名
		DeQueue(Fdancers, p); 							//女士出队
		printf("%s",p.name);							//输出出队女士姓名
		DeQueue(Mdancers, p); 							//男士出队
		printf("%s",p.name);							//输出出队男士姓名
	}
	if (!QueueEmpty(Fdancers)) 							//女士队列非空，输出队头女士的姓名
    { 
		p = GetHead(Fdancers); 							//取女士队头
		printf("The first woman to get a partner is:%s \n",p.name);
	} 
    else if (!QueueEmpty(Mdancers))						//男士队列非空，输出队头男士的姓名	
    { 
		p = GetHead(Mdancers); 							//取男士队头
		printf("The first man to get a partner is:%s \n",p.name);
	}
}
```

时间复杂度为$O(n)$，空间复杂度为$O(n)$。

# 第4章 串、数组和广义表

## 一、串

### 存储结构

#### 1.顺序存储

```c
//——————串的定长顺序存储结构——————
#define MAXSIZE 255											//串的最大长度
typedef struct 
{
	char ch[MAXSLEN+1];										//存储串的一维数组
    int length;												//串的当前长度
}SString;
//固定静态长度
```

```c
//——————串的堆式顺序存储结构——————
typedef struct
{
	char *ch;												//若是非空串，则按串长度分配储存区，否则ch为NULL
    int length;												//串的当前长度
}HString;
//动态可变长度
```

#### 2.链式存储

```c
//——————串的链式存储结构——————
#define CHUNKSIZE 80										//可由用户定义的块大小
typedef struct Chunk
{	
    char ch[CHUNKSIZE];
    struct Chunk *next;
}Chunk;
typedef struct
{
	Chunk *head,*tail;										//串的头指针和尾指针
    int length;												//串的当前长度
}LString;
```

存储时，可以用每个数据元素是一个字符，也可以是多个。当时多个的时候，如果不是结点大小的整数倍，链表中的最后一个结点通常用“#”补满或其他的非串值字符。

为方便串的操作，当以链表存储串值时，除头指针外，还可以附设一个尾指针指示链表中的最后一个结点，并给出当前串的长度。

存储密度小，运算处理方便，但是存储占用量大。如果需要在串处理过程中需要进行内、外存交换的话，会因为操作太多影像处理的总效率。除此之外，串的字符集的大小也是一个重要因素。

串值的链式存储结构有一定方便之处，但总的来说，不如顺序存储结构灵活，且占用存储量大且操作复杂。

### 模式匹配算法

**模式匹配**或**串匹配**：子串的定位运算。

#### 1.BF算法

```c
int Index_BF(SString S,SString T,int pos)
{//返回模式T在主串S中第pos个字符开始第一次的位置。若不存在，则返回值为0
 //其中，T非空，1≤pos≤S.length
    i=pos;	j=1;											 //初始化
    while(i<=S.length&&j<=T.length)							 //两个串均未比较到串尾
    {
		if(S.ch[i]==T.ch[j]){++i;++j;}						 //继续比较后继字符
        else{i=i-j+2;j=1;}									 //指针后退重新开始匹配
    }
    if(j>T.length)	return i-T.length;						 //匹配成功
    else return 0;											 //匹配失败
}
```

最好情况下的平均时间复杂度是$O(n+m)$。

最坏情况下的平均时间复杂度是$O(n\times m)$。

#### 2.KMP算法

##### next数组

首先我们来解释一个名词：最长公共前后缀。假设有一个串`P=“p0p1p2 …pj-1pj”`。如果存在`p0p1…pk-1pk = pj-kpj-k+1…pj-1pj`，我们就说在P串中有一个最大长度为k+1的公共前后缀。

###### next数组求值规则

$$
next[j]=
\begin{cases}
0& j=1\\
Max& {{k|1<k<j且有t_1t_2\cdots t_{k-1}=t_{j-k+1}t_{j-k+2}\cdots t_{j-1}}}\\
1&k=1(不存在相同子串，下一步进行t_1与s_i的比较)\\
\end{cases}\tag{4-1}
$$

| 下标 | 1    | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| P    | a    | b    | a    | a    | b    |
| Next | 0    | 1    | 1    | 2    | 2    |

**1.j=1**（j是指向字符串p的指针）根据上面的规则此时$Next[1]=0$

**2.j=2** p[j]=b,向前找公共字符串，此时前面只有一个元素a，属于上述第三种情况。此时$Next[2]=1$

**3.j=3** 向前找字串，没有公共子串，属于上述第三种情况，此时$Next[3]=1$

**4.j=4** 向前找字串,发现有公共子串$aba$ 其中a为公共子串，长度为1，所以$Next[4]=1+1$(如果有子串，那next的值为子串长度+1)，此时$Next[4]=2$

**5.j=5**,向前找字串,发现有公共子串 $abaa$ 其中a为公共子串，长度为1，此时$Next[5]=2$

（前缀：有第一个往后；后缀：有最后一个往前 ）

###### 计算next数组

```c
void get_next(SString T,int next[])
{//求模式串T的next函数值并存到数组next
	i=1;next[1]=0;j=0;
    while(i<T.length)
    {
		if(j==0||T.ch[i]==T.ch[j]){++i;++j;next[i]=j;}
        else j=next[j];
    }
}
```

时间复杂度为$O(m)$。

##### 代码实现

```c
int Index_KMP(SString S ,SString T,int pos)
{//利用模式串的T的next函数求T在主串S中第pos个字符以后的位置
 //其中，T非空，1≤pos≤S.length
    i=pos;j=1;
    while(i<=S.length&&j<=T.length)							//两个串均未比较到串尾
    {
		if(j==0||S.ch[i]==T.ch[j]){++i;++j;}				//继续比较后继字符
        else j=next[j];										//模式串向后移动
    }
	if(j>T.length)	return i-T.length;						//匹配成功
    else return 0;											//匹配失败
}
```

##### 优化

当出现模式“`aaaab`”和主串“`aaabaaaab`”匹配时
$$
\begin{array}{c|ccccc}
	j&1&2&3&4&5\\
	\hline {模式串}&a&a&a&a&b\\
	{next[j]}&0&1&2&3&4\\
	{nextval[j]}&0&0&0&0&4\\
\end{array}\tag{4-2}
$$
原有的算法会在相同的字符处反复浪费时间。

```c
void get_nextval(SString T,int nextval)
{//求模式串T的next函数修正值并存入数组nextval
	i=1;nextval[1]=0;j=0;
    while(i<T.length)
    {
		if(i==0||T.ch[i]==T.ch[j])
        {
			++i;++j;
            if(T.ch[i]!=T.ch[j])	nextval[i]=j;
            else	nextval[i]=nextval[j];
        }
        else	j=nextval[j];
    }
}
```

## 二、数组

数组：是类型相同的数据元素构成的有序集合，每个元素称为数组元素，可通过下标元素访问数据元素。

### 数组表示

#### 矩阵形式表示

$$
A_{m\times n}=\left[
\matrix{
a_{00}&a_{01}&a_{02}&\cdots&a_{0,n-1}\\
a_{10}&a_{11}&a_{12}&\cdots&a_{1,n-1}\\
\vdots &\vdots &\vdots &\quad &\vdots\\
a_{m-1,0}&a_{m-1,1}&a_{m-1,2}&\cdots&a_{m-1,n-1}\\
}
\right]\tag{4-3}
$$

#### 列向量的一维数组

$$
A_{m\times n}=\left[
\matrix{
\begin{array}{c|c|c}
a_{00}&a_{01}&a_{02}&\cdots&a_{0,n-1}\\
a_{10}&a_{11}&a_{12}&\cdots&a_{1,n-1}\\
\vdots &\vdots &\vdots &\quad &\vdots\\
a_{m-1,0}&a_{m-1,1}&a_{m-1,2}&\cdots&a_{m-1,n-1}\\
\end{array}}
\right]\tag{4-4}
$$

#### 行向量的一维数组

$$
A_{m\times n}=((a_{00},a_{01},a_{02},\cdots,a_{0,n-1}),
(a_{10},a_{11},a_{12},\cdots,a_{1,n-1}),
\cdots,
(a_{m-1,0},a_{m-1,1},a_{m-1,2},\cdots,a_{m-1,n-1}))
\tag{4-5}
$$

其中每个数据元素$a_j$是一个列向量形式的线性表
$$
a_j=(a_{0j},a_{1j},\cdots,a_{m-1,j})
\quad 0\le j \le n-1
\tag{4-5}
$$
其中每个数据元素$a_i$是一个行向量形式的线性表
$$
a_i=(a_{i0},a_{i1},\cdots,a_{i,n-1})
\quad 0\le i \le m-1
\tag{4-6}
$$
数组一旦被定义，它的维度和维界都不再改变。即只有存取、修改元素的操作。

### 顺序储存

每个元素占L个储存单元,任意一个元素$a_{ij}$的存储位置为
$$
LOC(i,j)=LOC(0,0)+(n\times i+j)L\tag {4-7}
$$
在Basic、Pascal、Java和C语言中，用的都是以行序为主序的存储结构，而在FORTRAN语言中，用的是以列序为主序的存储结构。

n维数组储存位置计算
$$
LOC(j_1,j_2,\cdots,j_n)=LOC(0,0,\cdots ,0)+\sum_{i=1}^n c_ij_i\\
c_n=L,c_{i-1}=b_i\times c_i,1<i\le n\tag{4-8}
$$

### 矩阵压缩

##### 1.对称矩阵

若n阶矩阵A中的元满足下述性质
$$
a_{ij}=a_{ji}\quad 1\le i,j\le n
\tag{4-9}
$$
则称为n阶对称矩阵。

对于对称矩阵，可以为每一对对陈元分配一个存储空间，则可以将$n^2$个元压缩存储到$n(n+1)/2$个元的空间中，不失一般性，可以行序为主序存储其下三角（包括对角线）中的元。

假设以一维数组$sa[n(n+1)/2]$作为$n$阶对称矩阵$A$的存储结构，则$sa[k]$和$a_{ij}$之间存在着一一对应的关系：
$$
k=
\begin{cases}
\frac{i(i-1)}{2}+j-1 &当i\geq j\\
\quad\\
\frac{j(j-1)}{2}+j-1 &当i<j\\
\end{cases}
\tag{4-10}
$$

##### 2.三角矩阵

###### (1)上三角矩阵

$sa[k]$和$a_{ij}$之间存在着一一对应的关系：
$$
k=
\begin{cases}
\frac{i(i-1)(2n-i+2)}{2} &当i\le j\\
\quad\\
\frac{n(n+1)}{2} &当i>j\\
\end{cases}
\tag{4-11}
$$


###### (2)下三角矩阵

$sa[k]$和$a_{ij}$之间存在着一一对应的关系：
$$
k=
\begin{cases}
\frac{i(i-1)}{2}+j-1 &当i\le j\\
\quad\\
\frac{j(j-1)}{2}+j-1 &当i>j\\
\end{cases}
\tag{4-12}
$$

##### 3.对角矩阵

**对角矩阵**所有的非零元都集中在以对角线为主对角线为中心的带状区域中，除此之外其他的元皆为零。也可按某个原则（或以行为主，或以对角线的顺序）将其压缩到一维数组上。

**稀疏矩阵**：其非零元教零元少，且分布没有一定规律。

## 三、广义表

广义表一般记作
$$
LS=(a_1,a_2,\cdots ,a_n)\tag{4-12}
$$

### 例子

1. $A=(\quad)$——$A$是一个空表，其长度为零
2. $B=(e)$——$B$只有一个原子$e$，其长度 为1
3. $C=(a,(b,c,d))$——$C$的长度为2，两个元素分别为原子a和子表$(b,c,d)$
4. $D=(A,B,C)$——$D$的长度为3，3个元素都是广义表。显然，将子表的值代入后，则有$D=((\quad),(e),(a,(b,c,d)))$
5. $E=(a,E)$——这是一个递归的表，其长度为2。$E$相当于一个我要宣布的广义表$E=(a,(a,(a,\cdots)))$

### 结论

1. 广义表的元素可以是子表，子表的元素还可以是子表，广义表可以是一个多层次结构。

2. 广义表可以为其他广义表共享。

3. 广义表可以是一个递归的表，即广义表本身也可以是其本身的一个子表。


### 操作

1. 取表头`GetHead(LS)`：取出的表头为非空广义表的第一个元素（子表或者单原子）。

2. 取表尾`GetTail(LS)`：取出的表尾为除去表头之外，由其余元素构成的表（一定是一个广义表）。


### 存储结构

#### （1）头尾链表的存储结构

```c
//——————广义表的头尾链表存储表示——————
typedef enum{ATOM,LIST} ElemTag;							 //ATOM==0:原子；LIST==1：子表
typedef struct GLNode
{
	ElemTag tag;											 //公共部分，用于区分原子结点和表结点
    union													 //原子结点和表结点的联合部分
    {
		AtomType atom;										 //atom是原子结点的值域，AtomType由用户定义
        struct{struct GLNode *hp,*tp;}ptr;																															 //ptr是表结点的指针域，ptr.hp和ptr.tp分别指向表头																 和表尾
    };
}*GList;													 //广义表类型
```

**表结点**

| tag=1 | hp   | hp   |
| ----- | ---- | ---- |

**原子结点**

| tag=0 | atom |
| ----- | ---- |

![](E:\资料\照片\781564-20160301001355642-510481726.png)

tag是标志域，值为1时表明结点是子表，值为0时表示结点是原子。

##### 特点

（1）除空表的表头指针为空外，对任何非空广义表，其表头指针均指向一个表结点，且该结点中的hp域指示广义表表头（或为原子结点，或为表结点），tp域指向广义表表尾（除非表尾为空，则指针为空，否则必为表结点）。

（2）容易分清列表中原子和子表所在层次。如在广义表D中，原子a和c在同一层次上，而b、c和d在同一层次且a和e第一层，B和C是同一层的子表。

（3）最高层的表结点个数即为广义表的长度。

#### （2）扩展线性链表的存储结构

![](E:\资料\照片\20181221185641403.png)

例如，A=(),B=(a),C=(a,(b,c)),D=(A,B,C),E=(a,E)

![](E:\资料\照片\20181221185700326.png)

```c
typedef enum{ATOM,LIST}ElemTag; 							   //ATOM=0，表示原子，LIST=1，表示子表
typedef struct
{
    ElemTag tag;                							   //标志位tag用于区分元素是原子还是子表
    union
    {
        AtomType atom;         								   //AtomType是原子结点的值域，用户自己定义类型
        struct
        {
            struct GLNode *hp,*tp;                             //hp指向表头，tp指向表尾
        }ptr;
    };
}*GList,GLNode;
```

## 四、案例

**病毒感染检测**

```c++
void Virus_detection()
{//利用BF算法实现病毒检测
	ifstream inFile("");
    ofstream outFile("");
    inFile>>num;											   //读取待检测的任务数
    while(num--)											   //依次检测每对病毒DNA和人的DNA是否匹配
    {
		inFile>>Virus.ch+1;									   //读取病毒DNA序列，字符串从下标1开始存放
        inFile>>Person.ch+1;								   //读取人的DNA序列
        Vir=Virus.ch;										   //将病毒DNA暂时存放在Vir中，以备输出
        flag=0;												   //用来标记是否匹配，初始为0，匹配后为非0
        m=Virus.length;										   //病毒DNA序列的长度是m
        for(i=m+1,j=1;j<=m;j++)
            Virus.ch[i++]=Virus.ch[j];						   //将病毒字符串的长度扩大2倍
        Virus.ch[2*m+1]='\0';								   //添加结束符号
        for(i=0;i<m;i++)									   //依次取的每个长度为m的病毒DNA环状字符串temp
        {
            for(j=1;j<=m;j++)	temp.ch[j]=Virus.ch[i+j];
            temp.ch[m+1]='\0';								   //添加结束符号
            flag=Index_BF(Person,temp,1);					   //模式匹配
            if(flag)	break;								   //匹配即可退出循环
        }													   //for
        if(flag)	outFile<<Vir+1<<"  "<<Person.ch+1<<" "<<"YES"<<endl;
        else		outFile<<Vir+1<<"  "<<Person.ch+1<<" "<<"NO"<<endl;
    }														   //while
}
```

上述算法时间复杂度为$O(num\times m \times m\times n)$。

# 第5章 数和二叉树

## 一、树的定义

**树**是$n(n\ge 0)$个结点的有限集，它或为空树$(n=0)$；或为为非空树，对于非空树$T$：

1. 有且仅有一个称为根的结点；
2. 除根结点外的其余结点可分为$m(m>0)$个互不相交的有限集$T_1,T_2,\cdots,T_m，$其中每一个集合本身又是一棵树，并且称为根的子树。

树的结构定义是一个递归的定义，即在树的定义中又用到树的定义，它道出了树的固有特性。树还有其他表示形式嵌套集合（即是一些集合的集体，对于其中任何两个集合，或不相交，或一个包含另一个）、广义表、凹入表示法等。

## 二、基本术语

![](E:\资料\照片\20210222170426652.png)

1. **结点**：树的一个独立单元。包含一个数据元素及若干指向其子树的分支。例：图中A、B、C、D等。
2. **结点的度**：结点拥有的子树数。例：图中A的度为3，B的度为2，F的度为0。
3. **树的度**：树内各结点度的最大值。例：图中树的度为3。
4. **叶子（终端结点）**：度为0的结点。例：结点K、L、M、I、J、G、F。
5. **非终端结点（分支结点）**：度不为0的结点，除根结点外，也称为内部结点。
6. **双亲和孩子**：结点的子树的根称为该结点的孩子，该结点称为孩子的双亲。例：B的双亲是A，B的孩子有E和F。
7. **兄弟**：同一个双亲的孩子之间互称兄弟。例：H、I和J互称兄弟。
8. **祖先**：从根到该结点所经分支上的所有结点。例：M的祖先是A、D和H。
9. **子孙**：从某个结点为根的子树中的任意结点都称为该结点的子孙。例：B的子孙是E、F、K和L。
10. **层次**：结点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任意结点的层次都等于其双亲结点的层次加1。
11. **堂兄弟**：双亲在同层的结点。例：结点B与C、D互为堂兄弟。
12. **树的深度**：树中结点的最大层次成为树的深度或高度。例：图中树的深度（高度）为4。
13. **有序树和无序树**：如果将树中结点的各子树看成从左至右是有次序的（即不能互换），则称该树为有序树，否则为无序树。在有序树的最左边的子树称为第一个孩子，最右边的称为最后一个孩子。
14. **森林**：是$m(m\ge 0)$棵互不相交的树的集合。对树中每个节点而言，其子树的集合即为森林。因此也可以用森林和树相互递归的定义来描述树。

任何一个树都是一个二元组$Tree=(root,F)$，其中$root$是数据元素，称作树的根结点；F是$m(m\ge 0)$棵树的森林，$F=(T_1,T_2,\cdots ,T_m)$，其中$T_i=(r_i,F_i)$称作根$root$的第$i$棵子树；当$m\ne 0$时，在树根和其子数森林之间存在下列关系：
$$
RF=\{<root,r_i>|i=1,2,4,m,m>0\}
\tag{5-1}
$$
这个定义将有助于得到森林和树与二叉树之间转换的递归定义。

## 三、二叉树

### 二叉树的定义

**二叉树**是$n(n\ge 0)$​个结点所构成的集合，它或为空树$(n=0)$；或为为非空树，对于非空树$T$：

1. 有且仅有一个称为根的结点；
2. 除根结点以外的其余结点分为两个互不相交的子集$T_1和T_2$，分别称为$T$的左子树和右子树，且$T_1和T_2$本身又都是二叉树。

二叉树五种状态：空二叉树、仅有根节点的二叉树、右子树为空的二叉树、左右子树均为非空的二叉树和左子树为空的二叉树。

![](E:\资料\照片\20210223141038540.png)

### 二叉树性质

**满二叉树**：深度为$k$且含有$2^k-1$个结点的二叉树。**特点**：每一层的结点数都是最大结点数，即每一层$i$的结点数都具有最大值$2^{i-1}$。

可以对满二叉树进行编号，约定编号从上到下，从左到右。

**完全二叉树**：深度为$k$的，有$n$结点的二叉树，当且仅当其每一个结点都与深度为$k$的满二叉树中编号从$1$到$n$的结点一一对应时称之为完全二叉树。**特点**：（1）叶子结点只可能在层次最大的两层出现；（2）对任一结点，若其右分支下的子孙的最大层次为$l$，则左分支下的最大层次必定是$l$或$l+1$。

1. 在二叉树的第$i$层至多有$2^{i-1}$个结点（$i\ge 1$）。

2. 深度为$k$的二叉树至多有$2^k-1$个结点（$k\ge 1$）。

3. 对任何一棵二叉树$T$，如果其终端结点数为$n_0$，度为2的结点数为$n_2$，则$n_0=n_2+1$。

4. 具有$n$个结点的完全二叉树的深度为$k=[\log _2n]+1$。

5.  如果对一棵有$n$个结点的完全二叉树（其深度为$[\log _2n]+1$）的结点按层序编号（从第$1$层到第$[\log _2n]+1$层，每层从左到右），则对任一结点$i$($1\le i\le n$)，有：

   （1）如果$i=1$，则结点$i$是二叉树的根，无双亲；如果$i>1$，则其双亲$PARENT(i)$是结点$[i/2]$。

   （2）如果$2i>n$，则结点$i$无左孩子（结点$i$为叶子结点）；否则其左孩子$LCHILD(i)$是结点。

   （3）如果$2i+1>n$，则结点$i$无右孩子；否则其右孩子$RCHILD(i)$是结点$2i+1$。

### 二叉树的存储结构

#### 顺序存储结构

```c
//——————二叉树的顺序存储表示——————
#define MAXTSIZE 100											//二叉树的最大结点数
typedef TElemType SqBiTree[MAXTSIZE];							//0号单元存储根节点
SqBiTree bt;	
```

这种顺序存储方式仅适合完全二叉树。对于一般二叉树，更适合采用下面的链式存储结构。

#### 链式存储结构

```c
//——————二叉树的二叉链表存储表示——————
typedef struct BiTNode{
    TElemType data;												//结点数据域
    struct BiTNode *lchild,*rchild(,*parent);					//左右孩子指针（双亲指针，三叉链表寻找双亲）
}BiTNode,*BiTree;
```

### 遍历二叉树

#### 递归算法

时间复杂度均为$O(n)$。

##### 先序遍历

![](E:\资料\照片\20210223151636759.png)

```c
void PreOrderTraverse(BiTree T)
{//先序遍历二叉树T的递归算法
	if(T)
    {
		printf("%TElemType",T->data);							//访问根节点
		PreOrderTraverse(T->lchild);							//先序递归遍历左子树
		PreOrderTraverse(T->rchild);							//先序递归遍历右子树
	}
}
```

##### 中序遍历

![](E:\资料\照片\2021022315230487.png)

```c
void InOrderTraverse(BiTree T)
{//中序遍历二叉树T的递归算法
	if(T)
    {
		InOrderTraverse(T->lchild);								//中序递归遍历左子树
        printf("%TElemType",T->data);							//访问根节点
		InOrderTraverse(T->rchild);								//中序递归遍历右子树
	}
}
```

##### 后序遍历

![](E:\资料\照片\20210223152835126.png)

```c
void PostOrderTraverse(BiTree T)
{//后序遍历二叉树T的递归算法
	if(T)
    {
		PostOrderTraverse(T->lchild);							//后序递归遍历左子树
		PostOrderTraverse(T->rchild);							//后序递归遍历右子树
        printf("%TElemType",T->data);							//访问根节点
	}
}
```

#### 非递归算法

时间复杂度均为$O(n)$。

##### 先序遍历

```c
void PreOrderTraverse(BiTree T)
{//先序遍历二叉树T的非递归算法
    InitStack(S);p=T;
    q=malloc(sizeof(BiTNode));
    while(p||!StackEmpty(S))
    {
		if(p)													//p非空
        {
			printf("%TElemType",T->data);						//访问根节点
            Push(S,p);											//根指针进栈
            p=p->lchild;										//根指针进栈，遍历左子树
        }
        else
        {
            Pop=(S,q);											//退栈
            p=q->rchild;										//遍历右子树
        }
    }															//while
}
```



##### 中序遍历

```c
void InOrderTraverse(BiTree T)
{//中序遍历二叉树T的非递归算法
    InitStack(S);p=T;
    q=malloc(sizeof(BiTNode));
    while(p||!StackEmpty(S))
    {
		if(p)													//p非空
        {
			Push(S,p);											//根指针进栈
            p=p->lchild;										//根指针进栈，遍历左子树
        }
        else
        {
            Pop=(S,q);											//退栈
            printf("%TElemType",T->data);						//访问根节点
            p=q->rchild;										//遍历右子树
        }
    }															//while
}
```

##### 后序遍历

```c
void PostOrderTraverse(BiTree T)
{//后序遍历二叉树T的非递归算法
    InitStack(S);p=T;
    q=malloc(sizeof(BiTNode));
    while(p||!StackEmpty(S))
    {
		if(p)													//p非空
        {
			Push(S,p);											//根指针进栈
            p=p->lchild;										//根指针进栈，遍历左子树
        }
        else
        {
            Pop=(S,q);											//退栈
            p=q->rchild;										//遍历右子树
            printf("%TElemType",T->data);						//访问根节点
        }
    }															//while
}
```

```c
void PostOrder2(BiTree T){
	InitStack(S);
	p = T;
	r = NULL;
	while(p || !IsEmpty(S))
    {
		if(p)
        {														//走到最左边
			push(S, p);
			p = p->lchild;
		}
        else
        {														//向右
			GetTop(S, p);										//读栈顶元素（非出栈）
			//若右子树存在，且未被访问过
			if(p->rchild && p->rchild != r)
            {
				p = p->rchild;									//转向右
				push(S, p);										//压入栈
				p = p->lchild;									//再走到最左
			}
            else
            {//否则，弹出结点并访问
				pop(S, p);										//将结点弹出
				visit(p->data);									//访问该结点
				r = p;											//记录最近访问过的结点
				p = NULL;
			}
		}
	}
```

#### 应用

##### 先序遍历的顺序建立二叉链表

```c
void CreatBiTree(BiTree &T)
{//按先序次序输入二叉树中结点的值（一个字符），创建二叉链表表示的二叉树T
	scanf("%c",&ch);
    if(ch=='#')	T=NULL;											//递归结束，建空树
    else														//递归创建二叉树
    {
        T=malloc(sizeof(BiTNode));								//生成根结点
        T->data=ch;												//根结点数据域置为ch
        CreatBiTree(T->lchild);									//递归创建左子树
        CreatBiTree(T->rchild);									//递归创建右子树
    }															//else
}
```

##### 复制二叉树

```c
void Copy(BiTree T,BiTree &NewT)
{//复制一棵和T完全相同的二叉树
	if(T==NULL)													//如果是空树，递归结束
    {
		NewT=NULL;
        return;
    }
    else
    {
        NewT=malloc(sizeof(BiTNode));
        NewT->data=T->data;										//复制根结点
        Copy(T->lchile,NewT->lchild);							//递归复制左子树
        Copy(T->rchile,NewT->rchild);							//递归复制右子树
    }															//else
}
```

##### 计算二叉树的深度

```c
int Deoth(BiTree T)
{//计算二叉树T的深度
	if(T==NULL)	return 0;										//如果是空树，深度为0，递归结束
    else
    {
		m=Depth(T->lchild);										//递归计算左子树的深度记为m
        n=Depth(T->rchild);										//递归计算右子树的深度记为n
		if(m>n)	return m+1;										//二叉树的深度为m与n的较大者加1
        else	return n+1;
    }
}
```

##### 统计二叉树中的结点个数

```c
int NodeCount(BiTree T)
{//统计二叉树T中结点个数
	if(T==NULL)	return 0;										 //如果是空树，则结点个数为0，递归结束
    else return NodeCount(T->lchild)+NodeCount(T->rchild)+1;	 //否则结点个数为左子树的结点个数+右子树的结点个																	 数+1
}
```

### 线索二叉树

#### 定义

若结点有左子树，则其$lchild$域指示其左孩子，否则令$lchild$域指示其前驱；若结点有右子树，则其$rchild$域指示其右孩子，否则令$rchild$域指示其后继。

| $lchild$ | $LTag$ | $data$ | $RTag$ | $rchild$ |
| :------: | :----: | :----: | :----: | :------: |

$$
LTag=
\begin{cases}
0\quad {lchild域指示结点的左孩子}\\
\quad\\
1 \quad {lchild域指示结点的前驱}\\
\end{cases}\tag{5-2}
$$

$$
RTag=
\begin{cases}
0\quad {rchild域指示结点的右孩子}\\
\quad\\
1 \quad {rchild域指示结点的后继}\\
\end{cases}\tag{5-2}
$$

二叉线索类型定义：

```c
//——————二叉树的二叉线索存储表示——————
typedef struct BiThrNode
{
	TElemType data;
    struct BiThrNode *lchild,*rchild;							 //左右孩子指针
    int LTag,RTag;												 //左右标志
}BiThrNode,*BiThrTree;
```

以这种结点结构构成的二叉链表作为二叉树的存储结构，叫做**线索链表**，其中指向结点前驱和后继的指针，叫做**线索**。加上线索的二叉树称之为**线索二叉树**。对二叉树以某种次序遍历使其变为线索二叉树的过程叫做**线索化**。

#### 构造

##### 以结点$p$为根的子树中序线索化

```c
void InThreading(BiThrTree p)
{//pre是全局变量，初始化时其右孩子指针为空，便于在数的最左点开始建线索
	if(p)
    {
		InThreading(p->lchild);									 //左子树递归线索化
        if(!p->lchild)											 //p的左孩子为空
        {
			p->LTag=1;											 //给p加上左线索
            p->lchild=pre;										 //p的左孩子指针指向pre（前驱）
        }														 //if
        else p->LTag=0;
        if(!pre->rchild)										 //pre的右孩子为空
        {
			pre->RTag=1;										 //给pre加上右线索
            pre->rchild=p;										 //pre的右孩子指针指向p（后继）
        }														 //if
        else pre->Rtag=0;
        pre=p;													 //保持pre指向p的前驱
        InThreading(p->rchild);									 //右子树递归线索化
    }
}
```

##### 带头结点的二叉树中序线索化

```c
void InOrderThreading(BiThrTree &Thrt,BiThrTree T)
{//中序遍历二叉树T，并将其中序线索化，Thrt指向头结点
	Thrt=malloc(sizeof(BiThrTree));								 //建立头结点
    Thrt->LTag=0;												 //头结点有做孩子，若树非空，则其左孩子为树根
    Thrt->RTag=1;												 //头结点的右孩子指针为右线索
    Thrt->rchild=Thrt;											 //初始化时右指针指向自己
    if(!T)	Thrt->lchild=Thrt;									 //若树为空，则左指针也指向自己
    else
    {
        Thrt->lchild;pre=Thrt;									 //头结点的左孩子指向根，pre初值指向头结点
        InThreading(T);											 //调用算法5.7,对以T为根的二叉树进行中序线索化
        pre->rchild=Thrt;										 //算法5．7结束后，pre为最右结点，pre的右线索指向头结点
        pre-RTag=1;
        Thrt->rchild=pre;										 //头结点的右线索指向pre
    }
}
```

#### 遍历

![image-20220528110138986](E:\资料\照片\image-20220528110138986.png)

##### 中序线索二叉树中查找

（1）查找p指针所指结点的前驱．

1. 若$p->LTag$为$1$，则$p$的左链指示其前驱。
2. 若$p->LTag$为$0$，则说明$p$有左子树，结点的前驱是遍历左子树时最后访问的一个结点（左子树中最右下的结点）。

（2）查找$p$指针所指结点的后继：

1. 若$p->RTag$为$$1$$，则$p$的右链指示其后继。以图中所示的中序线索树为例来看，结点b的后继为结点$*$。
2. 若$p->RTag$为$0$，则说明$p$有右子树。根据中序遍历的规律可知，结点的后继应是遍历其右子树时访问的第一个结点，即右子树中最左下的结点。例如在找结点$*$的后继时，首先沿右指针找到其右子树的根结点$-$，然后顺其左指针往下直至其左标志为$1$的结点，即为结点$*$的后继，在图中是结点$c$。

```c
void InOrderTraverse_Thr(BiThrTree T)
{//T指向头结点，头结点的左链lchild指向根结点，可参见线索化算法（带头结点的二叉树中序线索化）
 //中序遍历二叉线索树T的非递归算法，对每个数据元素直接输出
	p=T->lchild;												 //p指向根结点
    while(p!=T)													 //空树或遍历结束时，p==T
    {
		while(p->LTag==0) p=p->lchild;							 //沿左孩子向下
        printf("p->data");										 //访同其左子树为空的结点
        while(p->RTag==1&&p->rchild!=T)
        {
            p=p->rchild;printf("p->data");						 //沿右线索访同后继结点
        }
        p=p->rchild;											 //转向p的右子树
    }
}
```

##### 先序线索二叉树中查找

（1）查找$p$指针所指结点的前驱：

1. 若$p->LTag$为$1$ ,则$p$的左链指示其前驱；
2. 若$p->LTag$为$0$，则说明$p$有左子树。此时$p$的前驱有两种情况：若$*p$是其双亲的左孩子，则其前驱为其双亲结点；否则应是其双亲的左子树上先序遍历最宕访问到的结点。

（2）查找$p$指针所指结点的后继．

1. 若$p->RTag$为$1$ ,则$p$的右链指示其后继；
2. 若$p->RTag$为$0$，则说明$p$有右子树。按前序遍历的规则可知，$*p$的后继必为其左子树根（若存在）或右子树根。

##### 后序线索二叉树中查找

（1）查找$p$指针所指结点的前驱：

1. 若$p->LTag$为$1$ ，则p的左链指示其前驱;
2. 若$p->LTag$为$0$，当$p->RTag$也为$0$时，则p的右链指示其前驱；若$p->LTag$为$0$，而$p->RTag$为$1$时，则$p$的左链指示其前驱。

（2）查找$p$指针所指结点的后继情况比较复杂，分以下情况讨论：

1. 若加是二叉树的根，则其后继为空；
2. 若是其双亲的右孩子，则其后继为双亲结点;
3. 若是其双亲的左孩子，且没有右兄弟，则其后继为双亲结点；
4. 若*p是其双亲的左孩子，且有右兄弟，则其后继为双亲的右子树上按后序遍历列出的第一个结点（即右子树中“最左下"的叶结点)。

## 四、数和森林

### 树的存储结构

#### 1.双亲表示法

以一组连续的存储单元存储树的结点，每个结点出了数据域$data$外，还附设一个$parent$域的以指示其双亲结点的位置。

![双亲表示法的结点和示例](E:\资料\照片\image-20220530083015902.png)

#### 2.孩子表示法

由于树中每个结点可能有多个子树，则可用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根节点。

![孩子表示法的两种结点](E:\资料\照片\image-20220530084151010.png)

第一种结点格式，则多重链表中的结点是同构的，其中$d$为树的度。由于树中很多结点的度小于$d$，所以链表中有很多空链域，空间较浪费，在一棵有$n$个结点，度为$k$的树中必有$n(k-1)+1$个空链域。

第二种结点格式，则多重链表中的结点是不同构的，其中以$d$为结点的度，$degree$域的值同$d$。节约空间但操作不方便。

另一种方法，把每个结点的孩子结点排列起来，看成是一个线性表，且以点链表做存储结构，则$n$个孩子链（叶子的孩子链表为空表）。而$n$个头指针由组成一个线性表，为便于查找，可采用顺序存储结构。

![树的另外两种表示法](E:\资料\照片\树的另外两种表示法.png)

#### 3.孩子兄弟法（二叉树表示法或二叉链表表示法）

链表中结点的两个链域分别指向该节点的第一个孩子结点和下一个兄弟节点，分别命名为$firstchild$域和$nextsibling$域。

![孩子兄弟法的结点](E:\资料\照片\image-20220530094538352.png)

```c
//——————树的二叉链表（孩子-兄弟）存储表示——————
typedef struct CSNode
{
    ElemType data;
    struct CSNode *firstchild,*nextsibling;
}CSNode,*CSTree;
```

![image-20220530094904224](E:\资料\照片\树的二叉链表表示法.png)

优点：和二叉树的二叉链表表示完全一样，便于将一般的树结构转换为二叉树处理，利用二叉树算法处理。

### 森林和二叉树的转换

任何一棵和树对应的二叉树，其结点的右子树必空。若把森林中第二棵树的根结点看做是第一棵树的根结点的兄弟，则同样可以导出森林和二叉树的对应关系。

![image-20220530100401378](E:\资料\照片\森林和二叉树的对应关系.png)

#### 森林转换成二叉树

如果$F={T_1,T_2,\cdots,T_m}$是森林，则可按如下规则转换成一棵二叉树$B=(toot,LB,RB)$。

（1）若$F$为空，$m=0$，则$B$为空树；

（2）若非空，即$m\ne 0$，则$B$的根$root$即为森林中第一棵树的根$ROOT(T_1)$；$B$的左子树$LB$是从$T_1$中根结点的子树森林$F_1=\{T_{11},T_{12},\cdots ,T_{1m}\}$转换而成的二叉树；其右子树$RB$是从森林$F^\prime=\{T_2,T_3,\cdots,T_m\}$转换而成的二叉树。

#### 二叉树转换成森林

如果是一棵二叉树$B=(toot,LB,RB)$，则可按如下规则转换成森林$F=\{T_1,T_2,\cdots,T_m\}$。

（1）若$B$为空树，则$F$为空；

（2）若$B$非空，则$F$中第一棵树$ROOT(T_1)$的根即为二叉树$B$的根$root$；$T_1$中根结子的子树森林$F_1$是由$B$的左子树$LB$转换而成的森林；$F$中除$T_1$之外的其余树组成的森林$F^\prime=\{T_2,T_3,\cdots,T_m\}$是由$B$的右子树$RB$转换而成的森林。

### 树和树的遍历

#### 树的遍历

先序遍历和后序遍历。

#### 森林的遍历

##### 1.先序遍历

若森林非空，则可按下述规则遍历：

（1）访问森林中第一棵树的根结点；

（2）先序遍历第一棵树的根结点的子树森林；

（3）先序遍历除去第一棵树之后剩余的的树构成的森林。

##### 2.中序遍历

若森林非空，则可按下述规则遍历：

（1）中序遍历第一棵树的根结点的子树森林；

（2）访问森林中第一棵树的根结点；

（3）中序遍历除去第一棵树之后剩余的的树构成的森林。

## 五、哈夫曼树

### 定义和基础概念

**哈夫曼树**又称最优树，是一类权路径最短的树。

1. **路径**：从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径。

2. **路径长度**：路径上的分支数目称作路径长度。

3. **树的路径长度**：从树根到每一结点的路径长度之和。

4. **权**：赋予某个实体的一个量，是对实体某个或某些属性的数值化描述。在数据结构中，实体有结点（元素）和边（关系）两大类，所以对应有结点权和边权。结点权和边权具体代表什么意义，则对应的就有带权树等概念。

5. **结点的带权路径长度**：从该结点到树根之间的路径长度与结点上权的乘积。

6. **树的带权路径长度**：树中所有叶子结点的带权路径长度之和，通常记作
   $$
   WPL=\sum^{n}_{k=1} W_kl_k
   \tag{5-1}
   $$

7. **哈夫曼树**：假设有$m$个权值$\{w_1,w-2,\cdots,w_m\}$，可以构造一棵含有个$n$叶子结点的二叉树，每个叶子结点的权为$w_i$，则其中带权路径长度$WPL$最小的二叉树称作最优二叉树或哈夫曼树。

例子：三棵二叉树，都含有4个叶子结点$a、b、c、d$，分别带权$7、5、2、4$，它们的带权路径长度分别为

![具有不同带权路径长度的二叉树](E:\资料\照片\具有不同带权路径长度的二叉树.png)

### 构造算法

#### 构造过程

（1）根据给定的$n$个权值$\{w_1,w_2,\cdots,w_n\}$，构造$n$棵只有根结点的二叉树，这$n$棵二叉树构成一个森林$F$。

（2）在森林$F$中选取两棵结点数的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左、右子树上根结点的权值之和。

（3）在森林$F$中删除这两棵树，同时将新得到的二叉树加入$F$中。

（4）重复（2）和（3），直到$F$只含一棵树为止。这棵树便是哈夫曼树。

在构造哈夫曼树时，首先选择权小的，这样保证权大的离根较近，这样自然得到最小带权路径长度。

![image-20220531092403332](E:\资料\照片\哈夫曼树的构造过程.png)

#### 实现

哈夫曼树没有度为$1$的结点，则一颗有$n$个叶子结点的哈夫曼树共有$2n-1$个结点，可以存储在一个大小为$2n-1$的一维数组中。每个结点的存储结构：

![image-20220531092613588](E:\资料\照片\哈夫曼树结点形式.png)

```c
//——————哈夫曼树的存储表示——————
typedef struct
{
	int weight;													  //结点的权值
    int parent,lchild,rchild;									  //结点的双亲、左孩子、右孩子的下标
}HTNode,*HuffmanTree;											  //动态分配数组存储哈夫曼树
```

哈夫曼树的个结点存储在由$HuffmanTree$定义的动态分配的数组中，为了实现方便，数组的$0$号单元不使用，从$1$号单元开始使用，所以数组大小为$2n$。

##### 构造哈夫曼树

```c
void CreateHuffmanTree(HuffmanTree &HT,int n)
{
	if(n<=1) return;
    m=2*n-1;
    HT=malloc(sizeof(HTNode)*(m+1));							  //0号单元未用，所以需要动态分配m+1个单元，HT[m]表示根结点
    for(i=1;i<=n;++i)											  //将1~m号单元中的双亲、左孩子，右孩子的下标都初始化为0
    	{HT[i].parent=0;HT[i].lchild=0;HT[i].rchild=0;}
    for(i=1;i<=n;++i)											  //输入前n个单元中叶子结点的权值
    	printf(HT[i].weigth);
    //——————初始化工作结束，下面开始创建哈夫曼树——————
    for(i=n+1;i<=m;++i)
    {//通过n-1此选择、删除、合并来创建哈夫曼树
        Select(HT,i-1,s1,s2);
        //在HT[k](1≤k≤i-1)中选择两个其双亲域为0且权值最小的结点，并返回它们在HT中的序号s1和s2
        HT[s1].parent=i;Ht[s2].parent=i;
        //得到新结点i，从森林中删除s1，s2，将s1和s2的双亲域由0改为i
        HT[i].lchild=s1;HT[i].rchild=s2;						  //s1，s2分别作为i的左右孩子
        HT[i].weigth=HT{s1}.weight+Ht[s2].weight;				  //i的权值为左右孩子权值之和
    }															  //for
}
```

### 哈夫曼编码

#### 概念

（1）**前缀编码**：如果在一个编码方案中，任一个编码都不是其他任何编码的前缀（最左子串），则称编码是前缀编码。前缀编码可以保证对压缩文件进行解码时不产生二义性，确保正确解码。

（2）**哈夫曼编码**：对一棵具有$n$个叶子的哈夫曼树，若对树中每一个所分支赋予$0$，右分支赋予$1$，则从根到每个叶子的路径上，各分支的赋值分别构成一个二进制，该二进制串就成为哈夫曼编码。

##### 性质

（1）是前缀编码。

（2）是最优前缀编码。对于包括$n$个字符的数据文件，分别以它们的出现次数为权值构造哈夫曼树，则利用该树对应的哈夫曼编码对文件进行编码，能使该文件压缩后对应的二进制文件的长度最短。（以$n$种字符出现的频率做权）

#### 算法实现

**思想**：依次以叶子为出发点，向上回溯至根结点为止。走左分支生成代码为$0$，走右分支生成代码$1$。

```c
//——————哈夫曼编码表的存储表示——————
typedef char **HuffmanCode;											//动态分配数组存储哈夫曼编码表
```

为了不浪费存储空间，动态分配一个长度为$n$（字符编码长度一定小于$n$）的一维数组$cd$，用来临时存放当前正在求解的第$i$个字符的编码，当第$i$个字符的编码求解完成后，根据数组$cd$的字符串长度分配$HC[i]$的空间，然后将数组$cd$中的编码复制到$HC[i]$中。

```c
void CreatHuffmanCode(HuffmanTree HT,HuffmanCode &Hc,int n)
{//从叶子到根逆向求每个字符的哈夫曼编码，存在编码表HC中
	HC=malloc(sizeof(char *)*(n+1));							   //分配存储n个字符编码的编码表空间
    cd=malloc(sizeof(char)*(n));								   //分配临时存放每个字符编码的动态数组空间
    cd[n-1]='\0';												   //编码结束符
    for(i=1;i<=n;++i)											   //逐个字符求哈夫曼编码
    {
		start=n-1;												   //start开始时指向最后，即编码结束符位置
        c=i;f=HT[i].parent;										   //f指向结点c的双亲结点
        while(f!=0)												   //从叶子结点开始向上回溯，直到根结点
        {
			--start;											   //回溯一次start向前指一个位置
            if(HT[f].lchild==c) cd[start]='\0';					   //结点c是f的左孩子，则生成代码0
            else cd[start]='1';									   //结点c是f的右孩子，则生成代码1
            c==f;f=HF[f].parent;								   //继续向上回溯
        }														   //求出第i个字符的编码
        HC[i]=malloc(sizeof(char)*(n-start));					   //为第i个字符编码分配空间
        strcpy(HC[i],&cd[statr]);								   //将求得的编码从临时空间cd复制到HC的当前行中
    }															   //for
    free(cd);													   //释放临时空间
}
```

#### 文件的编码和译码

（1）**编码**：有了字符集的哈夫曼编码表之后，对数据文件的编码过程是：依次读入文件中的字符$c$，在哈夫曼编码表$HC$中找到此字符，将字符$c$转换为编码表中存放的编码串。

（2）**译码**：依次读入文件的二进制码，从哈夫曼的根结点（即$HT[m]$）出发，若当前读入为$0$，则走向左孩子，否则走向右孩子。一旦到达某一叶子$HT[i]$时便译出相应的字符编码$HC[i]$。然后重新从根出发继续译码，直至文件结束。

## 七、案例

### 利用二叉树求解表达式的值

#### 创建

```c
//OPTR暂存运算符；EXPT暂存已经建立好的表达式树的根结点
void InitExpTree()
{//表达式树的的创建算法
	InitStack(EXPT);											   //初始化EXPT栈
    InitStack(OPTR);											   //初始化OPTR栈
    Push(OPTR,'#');												   //将表达式初始符“#”压入OPTR栈    
    ch=getchar();
    while(ch!='#'||GetTop(OPTR)!='#')							   //表达式没有扫描完毕或OPTR的栈顶元素不是“#”
    {
		if(!In(ch))												   //ch不是运算符
        {
			CreatExpTree(T,NULL,NULL,ch);						   //以ch为根创建一棵只有根结点的二叉树
            Push(EXPT,T);										   //将二叉树结点T进EXPT栈
            ch=getchar();										   //读入下一字符
        }
        else
            switch(Precede(GetTop(OPTR),ch))					   //比较OPTR的栈顶元素和ch的优先级
            {
                case '<':
                    Push(OPTR,ch);ch=getchar();					   //当前字符ch压入OPTR栈，读入下一字符
                    break;
                case '>':
                    Pop(OPTR,theta);							   //弹出OPTR栈顶的运算符
                    Pop(EXPT,b);Pop(EXPT,a);					   //弹出EXPT栈顶的两个运算数
                    CreatExpTree(T,a,b,theta);
                    //以theta为根，a为左子树，b为右子树，创建一棵二叉树
                    Push(EXPT,T);								   //将二叉树根结点T近EXPT栈
                    break;
                case '=':										   //OPTR的栈顶元素时“（”且ch是“）”
                    Pop(OPTR,x);ch=getchar();					   //弹出OPTR栈顶的“（”，读入下一字符ch	
                    break;
            }													   //switch
    }															   //while
}//OPTR暂存运算符；EXPT暂存已经建立好的表达式树的根结点
void InitExpTree()
{//表达式树的的创建算法
	InitStack(EXPT);											   //初始化EXPT栈
    InitStack(OPTR);											   //初始化OPTR栈
    Push(OPTR,'#');												   //将表达式初始符“#”压入OPTR栈    
    ch=getchar();
    while(ch!='#'||GetTop(OPTR)!='#')							   //
    {
		if(!In(ch))
        {
			CreatExpTree(T,NULL,NULL,ch);
            Push(EXPT,T);
            ch=getchar();
        }
        else
            switch(Precede(GetTop(OPTR),ch))
            {
                case '<':
                    Push(OPTR,ch);ch=getchar();
                    break;
                case '>':
                    Pop(OPTR,theta);
                    Pop(EXPT,b);Pop(EXPT,a);
                    CreatExpTree(T,a,b,theta);
                    //以theta为根，a为左子树，b为右子树，创建一棵二叉树
                    Push(EXPT,T);
                    break;
                case '=':
                    Pop(OPTR,x);ch=getchar();
                    break;
            }
    }
}
```

#### 求值

```c
int EvaluateExpTree(BiTree T)
{//遍历表达式树进行表达式求值
	lvalue=rvalue=0;												//初始值为0
    if(T->lchild==NULL&&T->rchild==NULL)
        return T->data-'0';											//如果结点为操作数，则返回该结点的数值
    else															//如果结点为运算符
    {
		lvalue=EvaluateExpTree(T->lchild);							//递归计算左子树的值记为lvalue
        rvalue=EvaluateExpTree(T->rchild);							//递归计算右子树的值记为rvalue
        return GetValue(T->data,lvalue,rvalue);						//根据当前结点运算符的类型进行相应计算
    }
}
```

# 第6章 图

## 一、图的定义和基础术语

### 1.图的定义

**图**：$G$由两个集合$V$和$E$组成，记作$G=(V,E)$，其中$V$是顶点的有穷非空集合，E是V中顶点偶对的有穷集合，这些顶点偶对称为边。$V(G)$和$E(G)$通常表示图$G$的顶点集合和边集合，$E(G)$可以为空集。若$E(G)$为空，则图$G$只有顶点而没有边。

![image-20220601103045145](E:\资料\照片\图.png)

### 2.图的基础术语

（1）**子图**：假设有两个图$G= (V, E)$和$G' = (V', E')$,如果$V^\prime\sube V$且$E^\prime\sube E$，则称$G'$为$G$的子图。![image-20220601104056079](E:\资料\照片\子图示例.png)

（2）**无向完全图和有向完全图**：对于无向图，若具有$n(n-1)/2$条边，则称为**无向完全图**。对于有向图，若具有$n(n-1)$条弧，则称为**有向完全图**。

（3）**稀疏图和稠密图**：有很少条边或弧（如$e<n\log_2n$）的的图称为**稀疏图**，反之称为**稠密图**。

（4）**权和网**：在实际应用中，每条边可以标上具有某种含义的数值，该数值称为该边上的**权**。这些权可以表示从一个顶点到另一个顶点的距离或耗费。这种带权的图通常称为**网**。

（5）**邻接点**：对于无向图$G$,如果图的边$(v,v^\prime)\in E$，则称顶点$v$和$v'$互为邻接点，即$v$和$v'$**相邻接**。边$(v,v^\prime)$的**依附于**顶点$v$和$v'$,或者说边$(v,v^\prime)$与顶点$v$和$v'$**相关联**。

（6） **度、入度和出度**：顶点$v$的**度**是指和$v$相关联的边的数目，记为$TD(v)$。例如，下图中 $G2$的顶点$v_3$的度是3。对于有向图，顶点$v$的度分为入度和出度。**入度**是以顶点$v$为头的弧的数目，记为$ID(v)$；**出度**是以顶点$v$为尾的弧的数目，记为$OD(v)$。顶点$v$的度为$TD(v)=ID(v)+OD(v)$。例如，图中$G_1$的顶点$v_1$的入度$ID(v_1)=1$，出度$OD(v_1)=2$，度$TD(v_1)=ID(v_1)+OD(v_1)=3$。一般地，如果顶点$v_1$的度记为$TD(v_1)$，那么一个有$n$个顶点，$e$条边的图，满足如下关系 
$$
e=\frac{1}{2}\sum_{i=1}^nTD(v_i)
\tag{6-1}
$$
![image-20220601103045145](E:\资料\照片\图.png)

（7）**路径和路径长度**：在无向图$G$中，从顶点$v$到顶点$v^\prime$**路径**是一个顶点序列$(v=v_{i,0},v_{i,1},\cdots,v_{i,m}=v^\prime)$，其中$(v_{i,j-1},v_{i,j})\in E,1\le j\le m$。如果$G$是有向图，则路径也是有向的，顶点序列应满足$<v_{i,j-1},v_{i,j}>\in E,1\le j\le m$。**路径长度**是一条路径上经过的边或弧的数目。

（8）**回路或环**：第一个顶点和最后一个顶点相同的路径称为**回路**或**环**。

（9）**简单路径、简单回路或简单环**：序列中顶点不重复出现的路径称为**简单路径**。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为**简单回路**或**简单环**![img](file:///C:/Users/孤雨/AppData/Local/Temp/msohtmlclip1/01/clip_image021.jpg)

（10）**连通、连通图和连通分量**：在无向图$G$中，如果从顶点$v$到顶点$v'$有路径，则称$v$和$v' $是**连通**的。如果对于图中任意两个顶点$v_i,v_j\in V,v_i$和$v_j$都是连通的，则称$G$是**连通图**。图中的$G_2$就是一个连通图，而图中的$G_3$则是非连通图，但$G_3$有$3$个连通分量，如图所示。所谓**连通分量**，指的是无向图中的极大连通子图。

![image-20220601103045145](E:\资料\照片\图.png)![image-20220601110416084](E:\资料\照片\无向图及其连通分量.png)



（11）**强连通图和强连通分量**：在有向图$G$中，如果对于每一对$v_i,v_j\in V,v_i\ne v_j$，从$v_i$到$v_j$和从$v_j$到$v_i$都存在路径，则称$G$是强连通图。有向图中的极大强连通子图称作有向图的强连通分量。例如图中的$G_1$不是强连通图，但它有两个强连通分量，如图所示。

![image-20220601110644340](E:\资料\照片\G1的两个强连通分量.png)

（12）**连通图的生成树**：一个极小连通子图，它含有图中全部顶点，但只有足以构成一棵树的$n-1$条边，这样的连通子图称为**连通图的生成树**。图所示为$G_3$中最大连通分量的一棵生成树。如果在一棵生成树上添加一条边，必定构成一个环，因为这条边使得它依附的那两个顶点之间有了第二条路径。

![image-20220601111136937](E:\资料\照片\G3的最大连通分量的一棵生成树.png)

一棵有$n$个顶点的生成树有且仅有$n-1$条边。如果一个图有$n$个顶点和小于$n-1$条边，则是非连通图。如果它多于$n-1$条边，则一定有环。但是，有$n-1$ 条边的图不一定是生成树。

(13）**有向树和生成森林**：有一个顶点的入度为$0$，其余顶点的入度均为$1$的有向图称为**有向树**。一个有向图的**生成森林**是由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的**弧**。

![image-20220601111324404](E:\资料\照片\一个有向图及其生成森林.png)

## 二、图的存储结构

### 1.邻接矩阵

#### 邻接矩阵表示法

**邻接矩阵**：表示顶点之间按相邻关系的矩阵。设$G(V,E)$是具有$n$个顶点的图，则$G$的邻接矩阵是具有如下性质的$n$阶方阵
$$
A[i][j]=
\begin{cases}
1 \quad 若<v_i,v_j>或(v_i,v_j)\in E\\
\quad\\
0\quad 反之
\end{cases}
\tag{6-2}
$$
图的示例中$G_1$和$G_2$的邻接矩阵为：

![image-20220601160622421](E:\资料\照片\图的邻接矩阵.png)

若$G$是网，则邻接矩阵可以定义为
$$
A[i][j]=
\begin{cases}
w_{i,j} \quad 若<v_i,v_j>或(v_i,v_j)\in E\\
\quad\\
\infty \quad 反之
\end{cases}
\tag{6-2}
$$
其中，$w{i,j}$表示边上的权值；$\infty$表示计算机允许的，大于所有边上权值的数。

![image-20220601162742572](E:\资料\照片\网及其邻接矩阵.png)

用邻接矩阵表示法表示图，除了一个用于存储邻接矩阵的二维数组外，还需要用一个一维数组来存储顶点信息。

```c
//——————图的邻接矩阵存储表示——————
#define MaxInt 32767											  //表示极大值，即∞
#define MVNum  100												  //最大顶点数
typedef char VerTexType;										  //假设顶点的数据类型为字符型
typedef int  ArcType;											  //假设边的权值类型为整型
typedef struct
{
	VerTexType vexs[MVNum];										  //顶点表
    ArcType arcs[MVNum][MVNum];									  //邻接矩阵
    int vexnum,arcnum;											  //图的当前点数和边数
}AMGraph;
```

#### 创建无向网

```c
Status CreateUDN(AMGraph &G)
{//采用邻接矩阵表示法，创建无向网G
    scanf(G.vexnum,arcnum);											//输入总顶点数，总边数
	for(i=0;i<G.vexnum;++i)											//依次输入点的信息
        scanf(G.venxs[i]);
    for(i=0;i<G.vexnum;++i)											//初始化邻接矩阵，边的权值均置为极大值MaxInt
        for(j=0;j<G.vexnum;++j)
            G.arcs[i][j]=MaxInt;
    for(k=0;k<G.arcnum;++k)											//构造邻接矩阵
    {
		scanf(v1,v2,w);												//输入一条边依附的顶点及权值
        i=LocateVex(G,v1);j=LOcateVex(G,v2);						//确定v1和v2在G中的位置，即顶点数组的下标
        G.arcs[i][j]=w;												//边<v1,v2>的权值置为w
        G.arcs[j][i]=G.arcs[i][j];									//置<v1,v2>的对称边<v2,v1>的权值为w
    }																//for
    return OK;
}
```

该算法时间复杂度为$O(n^2)$。

若要建立无向图，只需要对上述算法改动：

（1）初始化邻接矩阵时，将边的权值初始化为$0$；

（2）构造邻接矩阵时，将权值$w$改为常量 $1$。（其余同）

#### 优缺点

##### （1）优点

1. 便于计算两个顶点之间是否有边，即根据$A[i][j]=0$或$1$来判断。
2. 便于计算各顶点的度。对于无向图，邻接矩阵第$i$行元素之和就是顶点$i$的度；对于有向图，第$i$行元素之和就是顶点$i$的出度，第$i$行元素之和就是顶点$i$的入度。

##### （2）缺点

1. 不便于增加和删除顶点。
2. 不便于统计边的数目，需要扫描邻接矩阵所有元素才能统计完毕，时间复杂度为$O(n^2)$。
3. 空间复杂度高。如果是有向图，$n$个顶点需要$n^2$个单元存储。如果是无向图，因其邻接矩阵是对称的，所以对规模较大的邻接矩阵可以采用压缩存储的方法，仅存储下三角（或上三角）的元素，这样需要$n(n-1)/2$个单元即可。但无论如何，其空间复杂度均为$O(n^2)$。

### 2.邻接表

#### 邻接表表示法

**邻接表**：图的一种链式存储结构。在邻接表中，对图中每个顶点$v_i$建立一个单链表，把与$v_i$相邻接的顶点放在这个链表中。邻接表中每个单链表的第一个结点存放有关顶点信息（链表表头），其余结点存放有关边的信息，即：表头结点和边表。

（1）**表头结点表**：由所有表头结点依顺序结构存储，表头结点包括**数据域**（$data$）【存储顶点$v_i$的名称或其他有关信息】和**链域**（$fisrtarc$）【指向链表中第一个结点（即与顶点$v_i$邻接的第一个邻接点】两部分。

（2）**边表**：由表示图中顶点间关系的$2n$个边链表组成。边链表中边结点包括**邻接点域**（$adjvex$）【指示与顶点$v_i$邻接的点在图中位置】、**数据域**（$info$）【存储和边相关信息，如权值】和**链域**（$nextarc$）【与顶点$v_i$邻接的下一条边的结点】。

![image-20220602102702560](E:\资料\照片\表头结点和边结点.png)

例下图分别为图中$G_1$和$G_2$的邻接表。

![](E:\资料\照片\图.png)

![image-20220602103155061](E:\资料\照片\邻接表和逆邻接表.png)

```c
//——————图的邻接表存储表示——————
 #define MVNum 100												  //最大顶点数
typedef struct ArcNode											  //边结点
{
	int adjvex;													  //该边所指向的顶点的位置
    struct ArcNode *nextarc;									  //和边相关的信息
    OtherInfo info;												  //和边相关的信息
}ArcNode;
typedef struct VNode											  //顶点信息
{
	VerTexType data;
    ArcNode *firstarc;											  //指向第一条依附该顶点的边的指针
}VNode,AdjList[MVNum];											  //AdjList表示邻接表类型
typedef struct													  //邻接表
{
    AdjList certices;
    int vexnum,arcnum;											  //图的当前的顶点数和
}ALGraph;
```

#### 创建无向图

```c
Status CreatUDG(ALGraph &G)
{//采用邻接表表示法，创建无向图G
    scanf(G.vexnum,G.arcnum);									  //输入总顶点数，总边数
	for(i=0;i<G.vexnum;++i)										  //输入各点，构造表头结点表
    {
		scanf(G.vertices[i].data);								  //输入顶点值
        G.vertices[i].firstarc=NULL;							  //初始化表头结点的指针域为NULL
    }															  //for
    for(k=0;k<G.arcnum;++k)										  //输入各边，构造邻接表
    {
        sacnf(v1,v2);											  //输入一条边依附的两个顶点
        i=LocateVex(G,v1);j=LocateVex(G,v2);
        //确定v1和v2在G中位置，即顶点在G.vertices中的序号
        p1=malloc(sizeof(ArcNode));								  //生成一个新的边结点*p1
        p1->adjvex=j;											  //邻接点序号为j
        p1->nextarc=G.vertices[i].firstarc;G.vertices[i].firstarc=p1;
        //将新结点*p1插入顶点vi的边表头部
        p2=malloc(sizeof(ArcNode));								  //生成一个新的边结点*p2
        p2->adjvex=i;											  //邻接点序号为i
        p2->nextarc=G.vertices[j].firstarc;G.vertices[j].firstarc=p2;
        //将新结点*p2插入到顶点vj的边表头部
    }
    return OK;													  //for
}
```

该算法的时间复杂度为$O(n+e)$。

建立有向图的邻接表与此类似，只是更加简单，每读入一个顶点对序号$<i,j>$，仅需生成一个邻接点序号为$j$的边表结点，并将其插入到$v_i$的边链表头部即可。若创建网的邻接表，可以将边的权值存储在$info$域中。

#### 优缺点

##### （1）优点

1. 便于增加和删除顶点。
2. 便于统计边的数目，按顶点表顺序扫描所有边表可得到边的数目，时间复杂度为 $O(n + e)$。
3. 空间效率高。对于一个具有$n$个顶点$e$条边的图$G$,若$G$是无向图，则在其邻接表表示中有$n$个顶点表结点和$2e$个边表结点；若$G$是有向图，则在它的邻接表表示或逆邻接表表示中均有$n$个顶点表结点和$e$个边表结点。因此，邻接表或逆邻接表表示的空间复杂度为$O(n + e)$, 适合表示稀疏图。对于稠密图，考虑到邻接表中要附加链域，因此常采取邻接矩阵表示法。

##### （2）缺点

1.  不便于判断顶点之间是否有边，要判定$v_i$和$v_j$之间是否有边，就需扫描第$i$个边表，最坏情况下要耗费$O(n)$时间。
2. ![img](file:///C:/Users/孤雨/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg)不便于计算有向图各个顶点的度。对于无向图，在邻接表表示中顶点的度是第$i$个边表中的结点个数。在有向图的邻接表中，第$i$个边表上的结点个数是顶点的出度，但求的人度较困难，需遍历各顶点的边表。若有向图采用逆邻接表表示，则与邻接表表示相反，求顶点的人度容易，而求顶点的出度较难。

### 3.十字链表（有向表）

**十字链表**：可以看成将有向图的邻接链表和逆邻接表结合的链表。其结构：

![image-20220602144101420](E:\资料\照片\弧结点和顶点结点.png)

**弧结点**：尾域（$tailvex$）和头域（$headvex$）分别指示弧尾和弧头这两个顶点在图中的位置；链域$hlink$指向弧头相同的下一条弧，而链域$tlink$指向弧尾相同的下一条弧；$info$域指向该弧的相关信息。

**顶点结点**：$data$域存储和顶点相关的信息；$firstin$和$firstout$分别指向以该顶点为弧头或弧尾的第一个弧结点。

![image-20220602150032735](E:\资料\照片\有向图的十字链表.png)

```c
//——————有向图的十字链表存储表示——————
#define MAX_VERTEX_NUM 20
typedef struct ArcBox
{
	int tailvext,headvex;										  //该弧的尾和头顶点位置
    struct ArcBox *hlinl,*tlink;								  //分别为弧头相同和弧尾相同的弧的链域
    InfoType *info;												  //该弧相关信息的指针
}ArcBox;
typedef struct VexNode
{
	VertexType data;
    ArcBox *firstin,*firstout;									  //分别指向该顶点第一条入弧和出弧
}VexNode;
typedef struct 
{
	VexNode xlist[MAX_VERTEX_NUM];								  //表头向量
    int vexnum,arcnum;											  //有向图的当前顶点数和弧数
}OLGraph;
```

### 4.邻接多重表（无向表）

每一条边用一个结点表示，**边结点**：$mark$为标志域【标记该条边是否被搜索过】；$ivex$和$jvex$为该边依附的两个顶点在图中位置；$ilink$指向下一条依附于$ivex$的边；$jlink$指向下一条依附于顶点$jvex$的边；$info$为指向和边相关的各种信息的指针域。

每一个顶点也用一个结点表示，**顶点结点**：$data$域存储和该顶点相关的信息；$firstedge$域指示第一条依附于该顶点的边。

![](E:\资料\照片\图.png)

![image-20220602152156324](E:\资料\照片\无向图G2的邻接多重表.png)

```c
//——————无向图的邻接多重表存储表示——————
#define MAX_VERTEX_NUM 20
typedef enmu{unvisited,visited} VisitIf;
typedef struct EBox
{
	VisitIf mark;												  //访问标记
    int ivex,jvex;												  //该边依附的两个顶点的位置
    struct EBox *ilink,*jlink;									  //分别指向依附这两个顶点的下一条边
    InfoType *info;												  //该边信息指针
}Ebox;
typedef struct VexBox
{
    VertexType data;
    EBox *firstedge;											  //指向第一条依附该顶点的边
}VexBox;
typedef struct
{
	VexBox adjmulist[MAX_VERTEX_NUM];
    int vexnum,edgenum;											  //无向图的当前顶点数和边数
}AMLGraph;
```

## 三、图的遍历

### 1.深度优先搜索

#### 过程

![image-20220603103258487](E:\资料\笔记\遍历图的过程.png)

#### 算法实现

##### 深度优先搜索遍历连通图

```c
bool visited[MVNum];												//访问标志数组，其初值为“false”
void DFS(Graph G,int v)
{//从第v个顶点出发递归地深度优先遍历图G
	printf(v);visited[v]=true;										//访问第v个顶点，并置访问标志数组和相应分量值为true
    for(w=FirstAdjVex(G,v);w>=0;w=NextAdjVex(G,v,w))
    //依次检查v的所有邻接点w，FirstAdjVex(G,v)表示v的第一个邻接点
    //NextAdjVex(G,v,w)表示v相对于w的下一个邻接点，w≥0表示存在临界点
        if(!visited[w]) DFS(G,w);									//对v的尚未访问的邻接顶点w递归调用DFS
}
```

##### 深度优先搜索遍历非连通图

```c
void DFSTraverse(Graph G)
{//对非连通图G做深度优先遍历
    for(v=0;v<G.vexnum;++v) visited[v]=false;						//访问标志数组初始化
    for(v=0;v<G.vexnum;++v)											//循环上述算法
        if(!visited[v]) DFS(G,v);									//对尚未访问的顶点调用DFS
}
```

##### 邻接矩阵表示图的深度优先搜索遍历

```c
void DFS_AM(AMGraph G,int v)
{//图G为邻接矩阵类型，从第v个顶点出发深度优先搜索遍历图G
	printf(v);visited[v]=true;										//访问第v个顶点，并置访问标志数组和相应分量值为true
    for(w=0;w,G.vexnum;w++)											//依次检查邻接矩阵v所在的行
        if((G.arcs[v][w]!=0)&&(!visited[w])) DFS(G,w);
    	//G.arcs[v][w]!=0表示w是v的邻接点，如果w未访问，则递归调用DFS
}
```

##### 邻接表表示图的深度优先搜索遍历

```c
void DFS_AM(AMGraph G,int v)
{//图G为邻接矩阵类型，从第v个顶点出发深度优先搜索遍历图G
	printf(v);visited[v]=true;										//访问第v个顶点，并置访问标志数组和相应分量值为true
    p=G.vertices[v].firstarc;										//p指向v的边链表的第一个边结点
    while(p!=NULL)													//边结点非空
    {
		w=p->adjvex;												//表示w是v的邻接点
        if(!visited[w]) DFS(G,w);									//如果w未访问，则递归调用DFS
        p=p->nextarc;												//p指向下一个边结点
    }																//while
}
```

### 2.广度优先搜索

#### 过程

![](E:\资料\照片\遍历图的过程.png)

#### 算法实现

**广度优先搜索遍历连通图**

```c
void BFS(Graph, G,int v)
{//按广度优先非递归遍历连通图
	printf(v);visited[v]=true;									  //访问v，并置访问标志数组分量值为true
    InitQueue(Q);												  //辅助队列Q初始化，置空
    EnQueue(Q,v);												  //v进队
    while(!QueueEmpty(Q))										  //队列非空
    {
		DeQueue(Q,u);											  //队头元素出队并置为u
        for(w=FirstyAdjVex(G,u);w>=0;w=NextAdjVex(G,u,w))
        //依次检查u的所有邻接点w，FrstAdjVex(G,u)表示u的第一个邻接点
        //NextAdjVex(G,u,w)表示u相对于w的下一个邻接点，w≥0表示存在邻接点
            if(!visited[w])										  //w为u的尚未访问的邻接顶点
            {
				printf(w);visited[w]=true;						  //访问w，并置访问标志数组分量值为true
                EnQueue(Q,w);									  //w进队
            }													  //if
    }															  //while
}
```

## 四、图的应用

### 1.最小生成树

在一个连通网的所有生成树中，各边的代价之和最小的那棵生成树称为该联通网的**最小代价生成树**，简称**最小生成树**。

#### 普里姆算法

![image-20220604093134880](E:\资料\照片\普里姆算法构造最小生成树的过程.png)

```c
//辅助数组的定义，用来记录从顶点集U到V-U的权值最小的边
struct
{
	VerTexType adjvex;												//最小边在U中的那个顶点
    ArcType    lowcost;												//最小边上的权值
}closedge[MVNum];
```

```c
void MiniSpanTree_Prim(AMGrpha G,VerTexType u)
{//无向网G以邻接矩阵形式存储，从顶点u出发构造G的最小生成树T，输出T的各条边
	k=LocateVex(G,u);											   //k为顶点u的下标
    for(j=0;j<G.vexnuml;++j)									   //对V-U的每一个顶点vj，初始化closedge[j]
        if(j!=k) closedge[j]={u,G,arcs[k][j]};					   //{adjvex,lowcost}
    closedge[k].lowcost=0;										   //初始，U={u}
    for(i=1;i<G.vexnum;++i)
    {//选择其余n-1个顶点，生成n-1条边(n=G.vexnum)
		k=Min(closedge);
        //求出T的下一个结点：第k个顶点，closedge[k]中存有当前最小边
    	u0=closedge[k].adjvex;									   //u0为最小边的一个顶点，u0∈V-U
        v0=G.vexs[k];											   //v0为最小边的另一个顶点，v0∈V-U
        printf(u0,v0);											   //输出当前的最小边(u0,v0)
        closedge[k].lowcost=0;									   //第k个顶点并入U集
        for(j=0;j<g.vexnum;++j)
            if(G.arcs[k][j]<closedge[j].lowcost)				   //新顶点并入U后重新选择最小边
                closedge[j]={G.vexs[k],G.arcs[k][j]};
    }															   //for
}
```

#### 克鲁斯卡尔算法

![image-20220604095157072](E:\资料\照片\克鲁斯卡尔算法构造最小生成树的过程.png)

```c
//辅助数组Edges的定义
struct
{
	verTexType Head;												//边的始点
    VerTextype Tail;												//边的终点
    ArcType lowcost;												//边上的权值
}
```

```c
void MiniSpanTree_Krusal(AMGraph G)
{//无向网G以邻接矩阵形式存储，构造G的最小生成树T，输出T的各条边
	Sort(Edge);													   //将数组Edge中的元素按权值从小到大排序
    for(i=0;i<G.vexnum;++i)										   //辅助数组，表示各顶点自成一个连通分量
        Vexser[i]=i;
    for(i=0;i<G.arcnum;++i)										   //依次查看数组Edge中的边
    {
		v1=LocateVex(G,Edge[i].Head);							   //vl为边的始点Head的下标
        v2=LOcatevex(G,Edge[i].Tail);							   //v2为边的终点Tail的下标
        vs1=vexset[v1];											   //获取边Edge[i]的始点所在的连通分量vs1
        vs2=Vexset[v2];											   //获取边Edge[i]的终点所在的连通分量vs2
        if(vs1！=vs2)											   //边的两个顶点分属不同的连通分量
        {
			printf(Edge[i].head,Edge[i].Tail);					   //输出此边
            for(j=0;j<G.vexnum;++j)								   //合并vs1和vs2两个分量，即两个集合统一编号 
                if(vexset[j]==vs2) Vexset[j]=vs1;				   //集合编号为vs2的都改为vsl  
        }														   //if
    }															   //for
}
```

### 2.最短路径

在带权有向网中，习惯上称路径的第一个顶点为**源点**，最后一个顶点为**终点**。

#### 从某个源点到其余各顶点的最短路径

```c
void ShortestPath_DIJ(AMGraph G,int v0)
{//用Dijkstra算法求有向网G的v0顶点到其余顶点的最短路径
    n=G.vexnum;													   //n为G中顶点的个数
    for(v=0;v<n;++v)											   //n个顶点依次
    {
		S[v]=false;												   //S初始为空集
        D[v]=G.arcs[v0][v];										   //将v0到各个终点的最短路径长度初始化为弧上的权值
        if(D[v]<MaxInt) Path[v]=v0;								   //如果v0和v之间有弧，则将v的前驱置为v0
        else Path[v]=-1;										   //如果v0和v之间无弧，则将v的前驱置为-1
    }															   //for
    S[v0]=true;													   //将v0加入S
    D[v0]=0;													   //源点到源点的距离为0
 //——————初始化结束，开始主循环，每次求得v0到某个顶点v的最短路径，将v加到S集——————
	for(i=1;i<N;++i)											   //对其余n-1个顶点，依次进行计算
    {
        min=MaxInt;
        for(w=0;w<n;++w)
            if(!S[w]&&D[w]<min)
            {v=w;min=D[w];}										   //选择一条当前的最短路径，终点为v
        S[v]=true;												   //将v加入S
        for(w=0;w<n;++w)										   //更新从v0出发到集合V-S上所有顶点的最短路径长度
            if(!S[w]&&(D[v]+G.arcs[v][w]<D[w]))
            {
				D[w]=D[v]+G.arcs[v][w];							   //更新D[w]
                Path[w]=v;										   //更改w的前驱为v
            }													   //if
    }															   //for
}
```

#### 每一对顶点之间的最短路径

```c
void ShortestPath_Floyd(AMGraph G)
{//用Floyd算法求有向网G中对各对顶点i和j之间的最短路径
    for(i=0;i<G.vexnum;++i)											//各对结点之间初始已知路径及距离
        for(j=0;j<G.vexnum;++j)
        {
			D[i][j]=G.arcs[i][j];
            if(D[i][j]<MaxInt) Path[i][j]=i;						//如果i和j之间有弧，则将j的前驱置为i
            else Path[i][j]=-1;										//如果i和j之间无弧，则将j的前驱置为-1
        }															//for
    for(k=0;k<G.vexnum;++k)
        for(i=0;i<G.vexnum;++i)
            for(j=0;j<G.vexnum;++j)
                if(D[i][j]+D[k][j]<D[i][j])							//从i经k到j的一条路径更短
                {
					D[i][j]=D[i][k]+D[k][j];						//更新D[i][j]
                    Path[i][j]=Path[k][j];							//更改j的前驱为k
                }													//if
}
```

### 3.拓扑排序

