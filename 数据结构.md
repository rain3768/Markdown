# 第1章 绪论

## 一、研究问题

数学模型和非数学模型（主要是线性表、树、图结构）

## 二、基础概念和术语

### 1.数据

客观事物的符号表示，所有能输入到计算机并能被计算机处理的符号的总称。

### 2.数据元素

数据基础单位，被作为一个整体考虑和处理。

### 3.数据项

最小单位，不可分割，有独立含义，组成数据元素。

### 4.数据对象

数据子集，性质相同元素集合。

### 5.数据结构

相互之间存在一种或多种特定关系的数据元素的集合。

#### (1)、逻辑结构

##### 两要素

数据元素和关系；

##### 分类

集合结构，树结构，图结构和网状结构，（前三种被称为非线性结构）线性结构

线性结构：线性表：一般线性表（线性表）、特殊线性表（栈与队列、字符串）、线性表的推广（数组、广义表）

非线性结构：树结构（树和二叉树）、图结构（有向和无向）、集合结构

#### (2)、存储结构

顺序存储结构、链式存储结构

#### (3)、数据类型和抽象数据类型

数据类型

抽象数据类型(ADT)：用户定义的、表示应用问题的数学模型以及定义在这个模型上的一组操作的总称。

```c
ADT 抽象数据类型名{
	数据对象:<数据对象的定义>
	数据关系:<数据关系的定义>
	基本操作:<基本操作的定义>
}ADT 抽象数据类型名
    
基本操作(参数表)
{
    初始条件:<初始条件描述>
    操作结果:<操作结果描述>
}
```

基础操作有两种参数：赋值结果只为操作提供输入值；引用参数以“&”打头，处可提供输入值外，还将返回操作结果。

## 三、算法和算法分析

### 1.算法的定义及特性

**算法**是为了解决某类问题而规定的一个有限长的操作序列。

（1）有穷性

（2）确定性

（3）可行性

（4）输入

（5）输出

### 2.评价算法优劣的基本标准

（1）正确性

（2）可读性

（3）健壮性：当输入非法数据事，做出正确反应或适当处理。

（4）高效性：包括时间和空间两方面。

### 3.时间复杂度

#### （1）问题规模和语句频度

**问题规模**：算法求解问题输入量的多少，是问题大小的本质表示，一般用整数$n$表示。

**语句频度**：一句语句的重复执行次数。

#### （2）时间复杂度定义

$$
T(n)=O(f(n))
$$

它表示随问题规模$n$增大，算法执行时间的增长率和$f(n)$的增长率相同，称作算法的**渐变时间复杂度**，简称**时间复杂度**。

#### （3）举例计算

##### 常量阶

```c
{x++;s=0;}
```

两条语句频度为1，算法的执行时间与问题规模$n$无关，是个常数，所以时间复杂度为$T(n)=O(1)$，成为常量阶。

##### 线性阶

```c
for(i=0;i<n;i++){x++;s=0;}
```

循环体内两条基本语句频度均为$f(n)=n$，所以算法时间复杂度为$T(n)=O(n)$，称为线性阶。

##### 平方阶

```c
x=0;y=0;
for(k=1;k<n;k++)
	x++;
for(i=1;i<n;i++)
    for(j=1;j<n;j++)
        y++;
```

对循环语句只需要考虑循环体中语句的执行次数，以上程序段中频度最大的语句是(6)，其频度为$f(n)=n^2$，所以该算法的时间复杂度为$T(n)=O(n^2)$，称为平方阶。

##### 对数阶

```c
for(i=1;i<n;i*=2)
{
	x++;
	s=0;
}
```

算法时间复杂度为$T(n)=O(\log_2 n)$。

常见时间复杂度按数量级递增排列依次为：常数阶、对数阶、线性阶、线性对数阶、平方阶、……、$k$次方阶、指数阶等。

#### （4）最好、最坏和平均时间复杂度

称算法最好情况下的时间复杂度为**最好时间复杂度**（计算量最小值），称算法最好情况下的时间复杂度为**最坏时间复杂度**（计算量最大值）。

算法的**平均时间复杂度**是指算法在所有可能情况下，按照输入实例一等概率出现时，算法计算量的加权平均值。

### 4.空间复杂度

$$
S(n)=O(f(n))
$$

##### 示例

```c
for(i=0;i<n/2;i++)
{
	t=a[i];
    a[i]=a[n-1-i];
    a[n-1-i]=t;
}
```

需要借助一个变量$t$，与问题规模$n$大小无关，所以空间复杂度为$O(1)$。

```c
for(i=0;i<n;i++)
    b[i]=a[n-1-i];
for(i=o;i<n;i++)
    a[i]=b[i];
```

需要另外借助一个大小为$n$的辅助数组$b$，所以空间复杂度为$O(n)$。

# 第2章 线性表

## 一、线性表的顺序储存表示

**顺序表**：用一组地址连续的储存单元一次储存表的数据元素。特点是逻辑上相邻的数据元素，其物理次序也是相邻的，是一种随机存取的储存结构。

```c
//-----顺序表的存储结构-----
#define MAXSIZE 100
typedef struct
{
    ElemType *elem;						//储存空间的基地址
    int length; 						//当前长度
}SqList;								//顺序表的结构类型为SqList
//ElemType是为了统一描述而自定的，根据实际为具体的数据类型。
```

## 二、基本操作实现

### 1.初始化

```c
Status InitList(SqList &L)
{//构造一个空的顺序表L
	L.elem=new ElemType[MAXSIZE];		//为顺序表分配一个大小为MAXSIZE的数组空间
    if(!L.elem) exit(OVERFLOW); 		//储存分配失败退出
    L.length=0;							//空表长度为0
    return OK;
}
```

其时间复杂度为$O(1)$。

### 2.取值

```c
Status GetElem(SqList L,int i,ElemType &e)
{
	if(i<1||i>L.length) return ERROR; 	 //判断i值是否合理，若不合理，返回ERROR
    e=L.elem[i-1];					 	 //elem[i-1]单元存储第i个数据元素
	return OK;
}
```

其时间复杂度为$O(1)$。

### 3.查找

```c
int LocateElem(SqList L,ElemType e)
{//在顺序表L中查找值为e的数据元素，返回其序号
    for(i=0;i<L.length;i++)
  		if(L.elem[i]==e) return i+1; 	//查找成功，返回序号i+1
	return 0;						 	//查找失败，返回0
}
```

在查找时，未确定元素在顺序表中的位置，需和给定值进行比较的数据元素个数的期望值称为查找算法在查找成功时的**平均查找长度**。

假设$p_i$是查找第$i$个元素的概率，$C_i$为找到表中其关键字与给定值相等的第$i$个记录时，和给定值已经进行过比较的关键字个数，则在长度为$n$的线性表中，查找成功时的平均查找长度为
$$
ASL=\sum_{i=1}^n p_iC_i
$$
其时间复杂度为$O(n)$。

### 4.插入

```c
Status ListInsert(SqList &L,int i,ElemType e)
{//在顺序表L中第i个位置插入新的元素e，i值的合法范围为1≤i≤L.length+1
	if((i<1)||(i>L.length+1)) return ERROR;//i值不合法
 	if(L.length==MAXSIZE) return ERROR;	   //储存空间已满
    for(j=L.length-1;j>=i-1;j--)
        L.elem[j+1]=L.elem[j];			   //插入位置及之后的元素后移
    L.elem[i-1]=e;						   //将新元素e放入第i个位置
    ++L.length;  						   //表长加一
    return OK;
}
```

其时间复杂度为$O(n)$。

### 5.删除

```c
Status ListDelete(SqList &L,int i)
{//在顺序表L中删除第i个元素，i值的合法范围是1≤i≤L.length
    if((i<1)||(i>L.length)) return ERROR;   //i值不合法
	for(j=i;j<=L.length-1;j++)
        L.elem[j-1]=L.elem[j];				//被删除元素之后的元素前移
    --L.length;								//表长减1
    return OK;
}
```

其时间复杂度为$O(n)$。

## 三、单链表

### 1.定义

**特点**：用一组任意的储存单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的。）

元素$a_i$：存储本身信息，存储一个指示其直接后继的信息（即直接后继的存储位置）。

**结点**（node）：这两部分信息组成数据元素$a_i$的存储映像。

**两个域**：**数据域**：其存储数据元素信息的域；**指针域**：存储直接后继存储位置的域。

指针域中存储的信息称作**指针**或**链**。$n$个结点（$a_i(a\leq i\leq n)$的储存映像）链结成一个**链表**。

```c
//——————单链表的存储结构——————
typedef struct  LNode
{
	ElemType data;							  //结点的数据域
    struct LNode *next;						  //结点的指针域
}LNode,*LinkList;							  //LinkList为指向结构体LNode的指针												  类型
```

**头结点**:在单链表的第一个结点之前附设一个结点，其指针域指向首元结点。

**首元结点**：链表中储存第一个数据元素$a_1$的结点。

**头指针**：指向链表中第一个结点的指针。若链表设有头指针，则头指针所指结点为线性表的头结点；若没有，则头指针指结点为该线性表的首元结点。

**作用**：（1）便于首元结点的处理；（2）便于空表和非空表的统一处理。

单链表是非随机存取的储存结构，要去的第$i$个数据元素必须从头指针出发顺链寻找，也成为**顺序存取**的存取结构。

### 2.操作

#### （1）初始化

```c
Status InitList(LinkList &L)
{//构造一个空的单链表L
	L=new LNode;								//生成新的结点作为头结点，用头指针L													 指向头结点
    L->next=NULL;								//头结点的指针域为空
    return OK;
}
```



#### （2）取值

```c
Status GetElem(LinkList L,int i,ElemType &e)
{//在带头结点的单链表L中根据序号i获取元素的值，用e返回L中第i个数据元素的值
	p=L->next;j=1;								//初始化，p指向首元结点，计数器j初													 值赋1
    while(p&&j<i)								//顺链域向后扫描，知道p为空或p指向													 第i个元素
    {
        p=p->next;								//p指向下一个结点
        ++j;									//计数器j相应加1
    }
    if(!p||j>i) return ERROR;					//i值不合法i>n或i≤0
    e=p->data;									//取第i个结点的数据域
    return OK;
}
```

时间复杂度为$O(n)$。

#### （3）按值查找

```c
LNode *LocateElem(LinkList L,ElemType e)
{//在带头结点的单链表L中查找值为e的元素
    p=L->next;									 //初始化，p指向首元结点
	while(p && p->data!=e)						 //顺链域向后扫描，直到p为空或p所													   指结点的数据等于e
        p=p->next;								 //p指向下一个节点
    return p;									 //查找成功返回值为e的结点地址p，													   查找失败p为NULL
}
```

时间复杂度为$O(n)$。

#### （4）插入

```c
Status ListInsert(LinkList &L,int i,ElemType e)
{//在带头结点的单链表L中第i个位置插入值为e的新结点
    p=L;j=0;
    while(P && (j<i-1))
    	{p=p->next;++j;}						//查找第i-1个结点，p指向该结点
	if(!p||j>i-1) return ERROR;					//i>n+1或者i<1
	s=new LNode;								//生成新结点*s
    s->data=e;									//将结点*s的数据域置为e
    s->next=p->next;							//将结点*s的指针域指向结点a
    p->next=s;									//将结点*p的指针域指向结点*s
    return OK;
}
```

时间复杂度为$O(n)$。

#### （5）删除

```c
Status ListDelete(LinkList &L,int i)
{//在带头结点的单链表L中，删除第i个元素
    p=L;j=0;
    while((p->next) && (j<i-1))					 //查找第i-1个结点，p指向该结点
    	{p=p->next;++j;}
    if(!(p->next)||(j>i-1))	return ERROR;		 //当i>n或i<1时，删除位置不合理
    q=p->next;									 //临时保存被删结点的地址已被释放
    p->next=q->next;							 //改变删除结点前驱结点的指针域
	delete q;									 //释放被删除结点的空间
    return OK;
}
```

时间复杂度为$O(n)$。

#### （6）创建单链表

##### 前插法

```c
void CreateList_H(LinkList &L,int n)
{//逆位序输入n个元素的值，建立带表头结点的单链表L
    L=new LNode;
    L->next=NULL;								  //先建立一个带头结点的空链表
    for(i=0;i<n;i++)
    {
		p=new LNode;							  //生成新结点*p
        cin>>p->data;							  //输入元素赋给新结点*p的数据域
        p->next=L->next;L->next=p;				  //将新结点*p插入到头结点之后
    }
	
}//cin>>相当于输入scanf
```

时间复杂度为$O(n)$。

##### 后插法

```c
void CreatList_R(LinkList &L,int n)
{//正位序输入n个元素的值，建立带表头结点的单链表L
    L=new LNode;
    L->next=NULL;								   //先建立一个带头结点的空链表
    r=L;										   //尾指针r指向头结点
    for(i=0;i<n;i++)
    {
		p=new LNode;							   //生成新结点
        cin>>p->data;							   //输入元素值赋给新节点*p的数据域
        p->next=NULL;r->next=p;					   //将新结点*p插入尾结点*r之后
        r=p;									   //r指向新的尾结点*p
    }
}
```

### 3.循环链表

**特点**：表最后一个结点的指针域指向头结点。

```c
// 终止判别
p!=L||p->next!=L;
```

**两个链表合并**

```c
p=B->next->next;
B->next=A->next;
A->next=p;
```

### 4.双向链表

**双向链表**：有两个指针域，一个指向直接后继，另一个指向直接前驱。

```c
//------双向链表的存储结构------
typedef struct DuLNode
{
	ElemType data;									//数据域
    struct DuLNode *prior;							//指向直接前驱
    struct DuLNode *next;							//指向直接后继
}DuLNode，*DuLinkList;
```

#### 操作

##### 插入

```c
Status Listinsert_DuL(DuLinkList &L,int i,ElemType e)//插入的结点为*s，原位置结点为*p
{//在带头结点的双向链表L中第i个位置之前插入元素e
    if(!(p=GetElem_DuL(L,i)))					   //在L中确定第i个元素的位置指针p
        return ERROR;							   //p为NULL时，第i个元素不存在
	s=new DuLNode;								   //生成新结点
    s->data=e;									   //将结点*s的数据域置为e
    s->prior=p->prior;							   //将结点*s插入L中
    p->prior->next=s;							   //让结点*p前的结点的直接后继指针域指向结点*p
    s->next=p;									   //让结点*s的后继指针域指向结点*p
    p->prior=s;									   //让结点*p的前驱指针域指向结点*s
    return OK;
}
```

其时间复杂度为$O(1)$ 。

##### 删除

```c
Status ListDelete_DuL(DuLinkList &L,int i)
{//删除带头结点的双向链表L中的第i个元素
    if(!(p=GetElem_DuL(L,i)))						//在L中确定第i元素的位置指针p
        return ERROR;								//p为NULL时，第i个元素不存在
    p->prior->next=p->next;							//修改被删结点的前驱结点的后继指针
    p->next->prior=p->prior;						//修改被删结点的后继结点的前驱指针
    delete p;										//释放被删结点的空间
    return OK;
}
```

其时间复杂度为$O(1)$ 。

### 5.线性表应用

#### （1）线性表合并

```c
void MergeList(List &LA,List LB)
{//将所有的线性表LB中但不在LA中的数据元素插入到LA中
	m=ListLength(LA); n=ListLength(LB);				//求线性表的长度
    for(i=1;i<=n;i++)
    {
        GetElem(LB,i,e);							//取LB中第i个数据元素赋给e
        if(!LocateElem(LA,e))						//LA中不存在和e相同的数据元素
            ListInsert(LA,++m,e);					//将e插在LA的最后
    }
}
```

其时间复杂度为$O(m\times n)$ 。

#### （2）顺序有序表

```c
void MergeList_Sq(SqList LA,SqList LB,SqList &LC)
{//已知顺序有序表LA和LB的元素按值非递减排列
 //归并LA和LB得到新的顺序有序表LC，LC的元素也按值非递减排列
    LC.length=LA.length+LB.length;					 //新表长度为待合并两表的长度之和
    LC.elem=new ElemType[LC.length];				 //为合并后的新表分配一个数组空间
    pc=LC.elem;										 //指针pc指向新表的第一个元素
    pa=LA.elem;	pa=LB.elem;							 //指针pa和pb的初值分别指向两个表的第一个元素
    pa_last=LA.elem+LA.length-1;					 //指针pa_last指向LA的最后一个元素
    pb_last=LB.elem+LB.length-1;					 //指针pa_last指向LB的最后一个元素
    while((pa<=pa_last)&&(pb<=pb_last))				 //LA和LB均为到达表尾
    {
		if(*pa<=*pb) *pc++=*pa++;					 //依次“摘取”两表中值较小的结点插入到LC的最后
        else *pc++=*pb++;
    }
	while(pa<=pa_last) *pc++=*pa++;					 //LB已到达表尾，依次将LA的剩余元素插入到LC的最后
    while(pb<=pb_last) *pc++=*pb++;					 //LA已到达表尾，依次将LB的剩余元素插入到LC的最后
}
```

时间复杂度和空间复杂度均为$O(m+n)$。

#### （3）链式有序表

```c
void MergeList_L(LinkList &LA,LinkList &LB,LinkList &LC)
{//已知单链表LA和LB的元素按值非递减排列
 //归并LA和LB的到新的单链表LC，LC的元素也按值非递减排列
    pa=LA->next;pb=LB->next;						  //pa和pb的初值分别指向两个表的第一个结点
    LC=LA;											  //用LA的头结点作为LC的头结点
    pc=LC;											  //pc的初值指向LC的头结点
    while(pa&&pb)
    {//LA和LB均为到达表尾，依次“摘取”两表中值较小的结点插入到LC的最后
        if(pa->data<=pb->data)						  //“摘取”pa所指结点
        {
            pc->next=pa;							  //将pa所指结点链接到pc所指结点之后
            pc=pa;									  //pc指向pa
            pa=pa->next;							  //pa指向下一个结点
        }
        else										  //“摘取”pb所指结点
        {
			pc->next=pb;							  //将pb所指结点链接到pc所指结点之后
            pc=pb;									  //pc指向pb
            pb=pb->next;							  //pb指向下一个结点
        }
    }												  //while
    pc->next=pa?pa:pb;								  //将非空表的剩余段插入到pc所指结点之后
    delete LB;										  //释放LB的头结点
}
```

时间复杂度为$O(m+n)$，空间复杂度为$O(1)$。没有开辟新的空间只是将原有结点，拆开打乱，组成一个新的链表。

#### （4）系数多项式的运算

其结构为

```c
typedef struct PNode
{
	float coef;											//系数
    int   expn;											//指针
    struct PNode *next;									//指针域
}PNode,*Polynomial;
```

##### a.多项式创建

```c
void CreatPolyn(Polynomial &p,int n)
{//输入n项的系数和指数，建立表示多项式的有序链表p
    P=new PNode;									   
    P->next=NULL;									   //先建立一个带头结点的单链表
    for(i=1;i<=n;++i)								   //依次输入n个非零项
    {
		s=new PNode;								   //生成新结点
        scanf("%f%d",&s.coef,&s.expn);				   //输入系数和指数
        pre=p;										   //pre用于保存q的前驱，初值为头结点
        q=P->next;									   //q初始化，指向首元结点
        while(q&&q->expn<s->expn)					   //通过比较指数找到第一个大于输入项指数的项*q
        {
            pre=q;
            q=p->next;
        }											   //while
        s->next=q;									   //将输入项s插入到q和其前驱结点pre之间
        pre->next=s;
    }												   //for
}
```

##### b.多项式相加

```c
void AddPolyn(Polynomial &Pa,Polynomial &Pb)
{//多项式加法：Pa=Pa+Pb，利用两个多项式的结构结点构成“和多项式”
	p1=Pa->next;p2=Pb->next;						   //p1和p2初值分别指向Pa和Pb的首元结点
    p3=Pa;											   //p3指向和多项式的当前结点，初值为Pa
    while(p1&&p2)									   //p1和p2均非空
    {
		if(p1->expn==p2->expn)						   //指数相等
        {
			sum=p1->coef+p2->coef;					   //sum保存两项的系数和
            if(sum!=0)								   //系数和不为0
            {
                p1->coef=sum;						   //修改Pa当前结点的系数值为两项系数的和
                p3->next=p1;p3=p1;					   //将修改后的Pa当前结点链在p3之后，p3指向p1
                p1=p1->next;						   //p1指向后一项
                r=p2;p2=p2->next;delete r;			   //删除Pb当前结点，p2指向后一项
            }
            else									   //系数和为0
        	{
            	r=p1;p1=p1->next;delete r;			   //删除Pa当前结点，p1指向后一项
            	r=p2;p2=p2->next;delete r;			   //删除Pb当前结点，p2指向后一项
        	}
        }
        else if(p1->expn<p2->expn)					   //Pa当前结点的指数值最小
        {
            p3->next=p1;							   //将p1链在p3之后
            p3=p1;									   //p3指向p1
            p1=p1->next;							   //p1指向后一项
        }
        else										   //Pb当前结点的指数值小
        {
            p3->next=p2;							   //将p2链在p3之后
            p3=p2;									   //p3指向p2
            p2=p2->next;							   //p2指向后一项
        }
    }												   //while
    p3->next=p1?p1:p2;								   //插入非控多项式的剩余段
    delete Pb;										   //释放Pb的头结点
}
```

时间复杂度为$O(m+n)$，空间复杂度为$O(1)$。 

# 第3章 栈和队列

## 一、定义

**栈**：限定仅在表尾进行插入或删除操作的线性表。（后进先出）

**栈顶**：表尾端；**栈底**：表头端

**队列**：是一种先进先出的线性表。

**队尾**：允许插入的一端；**队头**：允许删除的一端

## 二、顺序栈的表示和实现

### **顺序栈结构**

```c
//——————顺序栈的储存结构——————
#define MAXSIZE 100									    //顺序栈存储空间的初始分配量
typedef struct
{
	SElemType *base;									//栈底指针
	SElemType *top;										//栈顶指针
    int stacksize;										//栈可用的最大容量
}SqStack;
```

### 操作

#### 1.初始化

```c
Status InitStack(SqStack &s)
{//构造一个空栈S
    S.base=new SElemType[MAXSIZE];						//为顺序栈动态分配一个最大容量为MAXSIZE的数组空间
    if(!S.base)	exit(OVERFLOW);							//存储分配失败
    S.top=S.base;										//top初始为base，空栈
    S.stacksize=MAXSIZE;								//stacksize置为栈的最大容量stacksize
    return OK;
}
```

#### 2.入栈

```c
Status Push(SqStack &S,SElemType e)
{//插入元素e为新的栈顶元素
	if(S.top-S.base==S.stacksize)	return ERROR;		//栈满
    *S.top++=e;											//元素e压入栈顶，栈顶指针加1
    return OK;
}
```

#### 3.出栈

```c
Status Pop(SqStack &S,SElemType &e)
{//删除S的栈顶元素，用e返回其值
	if(S.top==S.base)	return ERROR;					//栈空
    e=*--S.top;											//栈顶指针减1，将栈顶元素赋给e
    return OK;	
}
```

#### 4.取栈顶元素

```c
SElemType GetTop(SqStack S)
{//返回S的栈顶元素，不修改栈顶指针
	if(S.top!=S.base)									//栈非空
        return *(S.top-1);								//返回栈顶元素的值，栈顶指针不变
}
```

### 注意

由于顺序栈和顺序表一样，受到最大空间容量的限制，因此在应用程序无法预先估计可能达到的最大容量时，还是应该使用下面介绍的链栈。

## 三、链栈的表示和实现

#### 定义

**链栈**：采用链式存储结构实现的栈。通常用单链表实现。

```c
//——————链栈的存储结构——————
typedef struct StackNode
{
	ElemType data;
    struct StackNode *next;
}StackNode,*linkStack;
```

以链表的头部作为栈顶是最方便的，而且不需要附加头结点。

#### 操作

##### 1.初始化

```c
Status InitStack(linkStack &s)
{//构造一个空栈S，栈顶指针置空
	S=NULL;
    return OK;
}
```

##### 2.入栈

```c
Status Push(LinkStack &S,SElemType e)
{//在栈顶插入元素e
    p=new StatckNode;									//生成新结点
    p->data=e;											//将新结点数据域置为e
    p->naxt=S;											//将新结点插入栈顶
	S=p;												//修改栈顶指针为p
    return OK;
}
```

##### 3.出栈

```c
Status Pop(LinkStack &S,SElemType &e)
{//删除S的栈顶元素，用e返回其值
    if(S==NULL)	return ERROR;							//栈空
    e=S->data;											//将栈顶元素赋给e
    p=S;												//用p临时保存栈顶元素空间，以备释放
    S=S->next;											//修改栈顶指针
    delete p;											//释放原栈顶元素的空间
    return OK;
}
```

##### 4.取栈顶元素

```c
SElemType GetTop(LinkStack S)
{//返回S的栈顶元素，不修改栈顶指针
    if(S!=NULL)											//栈非空
        return S->data;									//返回栈顶元素的值，栈顶指针不变
}
```

## 四、栈和递归

### 分治法

```c
void p()
{
	if(递归结束条件成立)可直接求解;							//递归终止的条件
    else p(较小的参数);									 //递归步骤
}
```

##### 应用分治法的问题条件

（1）能将一个问题转变成一个新的问题，而新问题与原问题的解法相同或类同，不同的仅是处理的对象，并且这些处理对象更小且更有规律。

（2）可以通过上述转化而使问题简化。

（3）必须有一个明确的递归出口，或称递归的边界。

## 五、队列的表示和实现

### 定义

队列也有两种储存方式，顺序表示和链式表示。

队列的**顺序存储结构**：

```c
//——————队列的顺序存储结构
#define MAXQSIZE 100									//队列可能达到的最大长度
typedef struct
{
	QElemType *base;									//存储空间的基地址
    int front;											//头指针
    int rear;											//尾指针
}SqQueue;
```

初始化时，令`front=rear=0`，每当插入新的队列尾元素时，尾指针rear增1；每当删除队列头元素时，头指针front加1。

因为队尾入队，队头出队，所以会造成假溢出。

为解决假溢出问题，所以利用“模”运算（`Q.rear=(Q.rear+1)%MAXQSIZE;`）来实现，称之为**循环列队**。

### 操作

#### 1.初始化

```c
Status InitQueue(SqQueue &Q)
{//构造一个空队列Q
    Q.base=new QElemType[MAXQSIZE];						//为队列分配一个最大空间为MAXQSIZE的数组空间
    if(!Q.base) exit(OVERFLOW);							//存储空间分配失败
	Q.front=Q.rear=0;									//头指针和尾指针位置为0，队列为空
    return OK;
}
```

#### 2.求队列长度

```c
int QueueLength(SqQueue Q)
{//返回Q的元素个数，即队列的长度
    return(Q.rear-Q.front+MAXQSIZE)%MAXQSIZE;
}
```

#### 3.入队

```c
Status EnQueue(SqQueue &Q,QElemType e)
{//插入元素e为Q的新的队列元素
    if((Q.rear+1)%MAXQSIZE==Q.front)					 //尾指针在循环意义上加1后等于头指针。表明队满
        return ERROR;
    Q.base[Q.rear]=e;									 //新元素插入队尾
    Q.rear=(Q.rear+1)%MAXQSZIE;							 //队尾指针加1
    return OK;											 
}
```

#### 4.出队

```c
Status DeQueue(SqQueue &Q,QElemType &e)
{//删除Q的队头元素，用e返回其值
    if(Q.front==Q.rear)	return ERROR;					 //队空
    e=Q.base[Q.front];									 //保存队友元素
    Q.front=(Q.front+1)%MAXQSIZE;						 //队头指针加一
    return OK;
}
```

#### 5.取队头元素

```c
QElemType GetHead(SqQueue Q)
{//返回的队头元素，不修改头指针
    if(Q.front!=Q.rear)									 //队列非空
		return Q.base[Q.front];							 //返回队头元素的值，队头指针不变
}
```

无法预测队列最大长度，则宜采用链对。

## 六、链队的表示和实现

### 定义

**存储结构**：

```c
//——————队列的链式存储结构——————
typedef struct QNode
{
	QElemType data;
    struct QNode *next;
}QNode,*QueuePtr;
typedef struct
{
    QueuePtr front;									    //队头指针
   	QueuePtr rear;										//队尾指针
}LinkQueue;
```

### 操作

#### 1.初始化

```c
Status InitQueue(LinkQueue &Q)
{//构造一个空队列Q
	Q.front=Q.rear=new QNode;							 //生成新的结点作为头结点，队头和队尾指针指向此结点
    Q.front->next=NULL;									 //头结点的指针域置空
    return Ok;
}
```

#### 2.入队

```c
Status EnQueue(LinkQueue &Q,QElemType e)
{//插入元素e为Q的新的队尾元素
	p=new QNode;										 //为入队元素分配结点空间，用指针p指向
    p->data=e;											 //将新结点数据域置为e
    p->next=NULL;Q.rear->next=p;						 //将新结点插入到队尾
    Q.rear=p;											 //修改队尾结点
    return OK;
}
```

#### 3.出队

```c
Status DeQueue(LinkQueue &Q,QElemType &e)
{//删除Q的队头元素，用e返回其值
    if(Q.front==Q.rear)	return ERROR;					//若队列空，则返回ERROR
    p=Q.front->next;									//p指向队头元素
    e=p->data;											//e保存队头元素的值
    Q.front->next=p->next;								//修改头结点的指针域
    if(Q.rear==p)	Q.rear=Q.front;						//最后一个元素被删，队尾指针指向头结点
    delete p;											//释放原队头元素的空间
    return OK;
}
```

#### 4.取队头元素

```c
QElemType GetHead(LinkQueue Q)
{//返回Q的队头元素，不修改队头指针
	if(Q.front!=Q.rear)									 //队列非空
        return Q.front->next->data;						 //返回队头元素的值，队头指针不变
}
```

## 七、案例

### 括号匹配的检验

#### 操作

```c
Status Matching() 
{//检验表达式中所含括号是否正确匹配，如果匹配，则返回true，否则返回false
 //表达式以“#”结束
	InitStack(S); 										//初始化空栈
	int flag = 1; 										//标记匹配结果以控制循环及返回结果
	ch=getchar();										//读入第一个字符
	while (ch != '#' && flag)							//假设表达式以“#”结尾
	{
		switch (ch) {
		case '[' :
		case '(': 										//若是左括号，则将其压入栈
			Push(S, ch);
			break;
		case ')': 										//若是“)”，则根据当前栈顶元素的值分情况考虑
			if (!StackEmpty(S) && GetTop(S) == '(')
				Pop(S, x); 								//若栈非空且栈顶元素是“(”，则正确匹配
			else
				flag = 0; 								//若栈空或栈顶元素不是“(”，则错误失败
			break;
		case ']': 										//若是“]”，则根据当前栈顶元素的值分情况考虑
			if (!StackEmpty(S) && GetTop(S) == '[')
				Pop(S, x); 								//若栈非空且栈顶元素是“[”，则正确匹配
			else
				flag = 0;								//若栈空或栈顶元素不是“[”，则错误匹配
			break;
		} 												//switch
		ch=getchar(); 									//继续读入下一个字符
	} 													//while
	if (StackEmpty(S) && flag) return true; 			//匹配成功
	else return false; 									//匹配失败
}
```

时间复杂度为$O(n)$，空间复杂度为$O(n)$。

### 表达式求值

#### 操作

```c
char EvaluateExpression() 
{//算术表达式求值的算符优先算法，设OPTR和OPND分别为运算符栈和操作数栈
	InitStack(OPND); 									//初始化OPND栈
	InitStack(OPTR); 									//初始化OPTR栈
	Push(OPTR, '#'); 									//将表达式起始符“#”压入OPTR栈
	cin >> ch;
	while (ch != '#' || (GetTop(OPTR) != '#')) 			//表达式没有扫描完毕或OPTR的栈顶元素不为“#”
	{
		if (!In(ch)) {
			Push(OPND, ch);
			ch=getchar();
		} 												//ch不是运算符则进OPND栈
		else
			switch (Precede(GetTop(OPTR), ch)) 			//比较OPTR的栈顶元素和ch的优先级
			{
			case '<':
				Push(OPTR, ch);
				ch=getchar(); 							//当前字符ch压入OPTR栈，读入下一字符ch
				break;
			case '>':
				Pop(OPTR, theta); 						//弹出OPTR栈顶的运算符
				Pop(OPND, b);
				Pop(OPND, a); 							//弹出OPND栈顶的两个运算数
				Push(OPND, Operate(a, theta, b)); 		//将运算结果压入OPND栈
				break;
			case '=': 									//OPTR的栈顶元素是“(”且ch是“)”
				Pop(OPTR, x);
				ch=getchar(); 							//弹出OPTR栈顶的“(”，读入下一字符ch
				break;
			} 											//switch
	} 													//while
	return GetTop(OPND);								//OPND栈顶元素即为表达式求值结果
}
```

时间复杂度为$O(n)$，空间复杂度为$O(n)$。

### 舞伴问题

#### 结构定义

```c
//- - - - - 跳舞者个人信息- - - - - 
typedef struct {
	char name[20]; 										//姓名
	char sex; 											//性别，'F'表示女性，'M'表示男性
} Person;

//- - - - - 队列的顺序存储结构- - - - - 
#define MAXQSIZE 100
typedef struct {
	Person *base; 										//队列中数据元素类型为Person
	int front; 											//头指针
	int rear; 											//尾指针
} SqQueue;

SqQueue Mdancers, Fdancers; 							//分别存放男士和女士入队者队列
```

#### 操作

```c
void DancePartner(Person dancer[], int num)
{//结构数组dancer中存放跳舞的男女，num是跳舞的人数。
	InitQueue(Mdancers); 								//男士队列初始化
	InitQueue(Fdancers); 								//女士队列初始化
	Person p;
	for (int i = 0; i < num; i++) 						//依次将跳舞者根据其性别入队
	{
		p = dancer[i];
		if (p.sex == 'F') EnQueue(Fdancers, p); 		//插入女队
		else EnQueue(Mdancers, p); 						//插入男队
	}
	printf("The dancing partners are:\n");
	while (!QueueEmpty(Fdancers) && !QueueEmpty(Mdancers)) 
    {//依次输出男女舞伴的姓名
		DeQueue(Fdancers, p); 							//女士出队
		printf("%s",p.name);							//输出出队女士姓名
		DeQueue(Mdancers, p); 							//男士出队
		printf("%s",p.name);							//输出出队男士姓名
	}
	if (!QueueEmpty(Fdancers)) 							//女士队列非空，输出队头女士的姓名
    { 
		p = GetHead(Fdancers); 							//取女士队头
		printf("The first woman to get a partner is:%s \n",p.name);
	} 
    else if (!QueueEmpty(Mdancers))						//男士队列非空，输出队头男士的姓名	
    { 
		p = GetHead(Mdancers); 							//取男士队头
		printf("The first man to get a partner is:%s \n",p.name);
	}
}
```

时间复杂度为$O(n)$，空间复杂度为$O(n)$。

# 第4章 串、数组和广义表

## 一、串

### 存储结构

#### 1.顺序存储

```c
//——————串的定长顺序存储结构——————
#define MAXSIZE 255											//串的最大长度
typedef struct 
{
	char ch[MAXSLEN+1];										//存储串的一维数组
    int length;												//串的当前长度
}SString;
//固定静态长度
```

```c
//——————串的堆式顺序存储结构——————
typedef struct
{
	char *ch;												//若是非空串，则按串长度分配储存区，否则ch为NULL
    int length;												//串的当前长度
}HString;
//动态可变长度
```

#### 2.链式存储

```c
//——————串的链式存储结构——————
#define CHUNKSIZE 80										//可由用户定义的块大小
typedef struct Chunk
{	
    char ch[CHUNKSIZE];
    struct Chunk *next;
}Chunk;
typedef struct
{
	Chunk *head,*tail;										//串的头指针和尾指针
    int length;												//串的当前长度
}LString;
```

存储时，可以用每个数据元素是一个字符，也可以是多个。当时多个的时候，如果不是结点大小的整数倍，链表中的最后一个结点通常用“#”补满或其他的非串值字符。

为方便串的操作，当以链表存储串值时，除头指针外，还可以附设一个尾指针指示链表中的最后一个结点，并给出当前串的长度。

存储密度小，运算处理方便，但是存储占用量大。如果需要在串处理过程中需要进行内、外存交换的话，会因为操作太多影像处理的总效率。除此之外，串的字符集的大小也是一个重要因素。

串值的链式存储结构有一定方便之处，但总的来说，不如顺序存储结构灵活，且占用存储量大且操作复杂。

### 模式匹配算法

**模式匹配**或**串匹配**：子串的定位运算。

#### 1.BF算法

```c
int Index_BF(SString S,SString T,int pos)
{//返回模式T在主串S中第pos个字符开始第一次的位置。若不存在，则返回值为0
 //其中，T非空，1≤pos≤S.length
    i=pos;	j=1;											 //初始化
    while(i<=S.length&&j<=T.length)							 //两个串均未比较到串尾
    {
		if(S.ch[i]==T.ch[j]){++i;++j;}						 //继续比较后继字符
        else{i=i-j+2;j=1;}									 //指针后退重新开始匹配
    }
    if(j>T.length)	return i-T.length;						 //匹配成功
    else return 0;											 //匹配失败
}
```

最好情况下的平均时间复杂度是$O(n+m)$。

最坏情况下的平均时间复杂度是$O(n\times m)$。

#### 2.KMP算法

##### next数组

首先我们来解释一个名词：最长公共前后缀。假设有一个串`P=“p0p1p2 …pj-1pj”`。如果存在`p0p1…pk-1pk = pj-kpj-k+1…pj-1pj`，我们就说在P串中有一个最大长度为k+1的公共前后缀。

###### next数组求值规则

$$
next[j]=
\begin{cases}
0& j=1\\
Max& {{k|1<k<j且有t_1t_2\cdots t_{k-1}=t_{j-k+1}t_{j-k+2}\cdots t_{j-1}}}\\
1&k=1(不存在相同子串，下一步进行t_1与s_i的比较)\\
\end{cases}\tag{4-1}
$$

| 下标 | 1    | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| P    | a    | b    | a    | a    | b    |
| Next | 0    | 1    | 1    | 2    | 2    |

**1.j=1**（j是指向字符串p的指针）根据上面的规则此时$Next[1]=0$

**2.j=2** p[j]=b,向前找公共字符串，此时前面只有一个元素a，属于上述第三种情况。此时$Next[2]=1$

**3.j=3** 向前找字串，没有公共子串，属于上述第三种情况，此时$Next[3]=1$

**4.j=4** 向前找字串,发现有公共子串$aba$ 其中a为公共子串，长度为1，所以$Next[4]=1+1$(如果有子串，那next的值为子串长度+1)，此时$Next[4]=2$

**5.j=5**,向前找字串,发现有公共子串 $abaa$ 其中a为公共子串，长度为1，此时$Next[5]=2$

（前缀：有第一个往后；后缀：有最后一个往前 ）

###### 计算next数组

```c
void get_next(SString T,int next[])
{//求模式串T的next函数值并存到数组next
	i=1;next[1]=0;j=0;
    while(i<T.length)
    {
		if(j==0||T.ch[i]==T.ch[j]){++i;++j;next[i]=j;}
        else j=next[j];
    }
}
```

时间复杂度为$O(m)$。

##### 代码实现

```c
int Index_KMP(SString S ,SString T,int pos)
{//利用模式串的T的next函数求T在主串S中第pos个字符以后的位置
 //其中，T非空，1≤pos≤S.length
    i=pos;j=1;
    while(i<=S.length&&j<=T.length)							//两个串均未比较到串尾
    {
		if(j==0||S.ch[i]==T.ch[j]){++i;++j;}				//继续比较后继字符
        else j=next[j];										//模式串向后移动
    }
	if(j>T.length)	return i-T.length;						//匹配成功
    else return 0;											//匹配失败
}
```

##### 优化

当出现模式“`aaaab`”和主串“`aaabaaaab`”匹配时
$$
\begin{array}{c|ccccc}
	j&1&2&3&4&5\\
	\hline {模式串}&a&a&a&a&b\\
	{next[j]}&0&1&2&3&4\\
	{nextval[j]}&0&0&0&0&4\\
\end{array}\tag{4-2}
$$
原有的算法会在相同的字符处反复浪费时间。

```c
void get_nextval(SString T,int nextval)
{//求模式串T的next函数修正值并存入数组nextval
	i=1;nextval[1]=0;j=0;
    while(i<T.length)
    {
		if(i==0||T.ch[i]==T.ch[j])
        {
			++i;++j;
            if(T.ch[i]!=T.ch[j])	nextval[i]=j;
            else	nextval[i]=nextval[j];
        }
        else	j=nextval[j];
    }
}
```

## 二、数组

数组：是类型相同的数据元素构成的有序集合，每个元素称为数组元素，可通过下标元素访问数据元素。

### 数组表示

#### 矩阵形式表示

$$
A_{m\times n}=\left[
\matrix{
a_{00}&a_{01}&a_{02}&\cdots&a_{0,n-1}\\
a_{10}&a_{11}&a_{12}&\cdots&a_{1,n-1}\\
\vdots &\vdots &\vdots &\quad &\vdots\\
a_{m-1,0}&a_{m-1,1}&a_{m-1,2}&\cdots&a_{m-1,n-1}\\
}
\right]\tag{4-3}
$$

#### 列向量的一维数组

$$
A_{m\times n}=\left[
\matrix{
\begin{array}{c|c|c}
a_{00}&a_{01}&a_{02}&\cdots&a_{0,n-1}\\
a_{10}&a_{11}&a_{12}&\cdots&a_{1,n-1}\\
\vdots &\vdots &\vdots &\quad &\vdots\\
a_{m-1,0}&a_{m-1,1}&a_{m-1,2}&\cdots&a_{m-1,n-1}\\
\end{array}}
\right]\tag{4-4}
$$

#### 行向量的一维数组

$$
A_{m\times n}=((a_{00},a_{01},a_{02},\cdots,a_{0,n-1}),
(a_{10},a_{11},a_{12},\cdots,a_{1,n-1}),
\cdots,
(a_{m-1,0},a_{m-1,1},a_{m-1,2},\cdots,a_{m-1,n-1}))
\tag{4-5}
$$

其中每个数据元素$a_j$是一个列向量形式的线性表
$$
a_j=(a_{0j},a_{1j},\cdots,a_{m-1,j})
\quad 0\le j \le n-1
\tag{4-5}
$$
其中每个数据元素$a_i$是一个行向量形式的线性表
$$
a_i=(a_{i0},a_{i1},\cdots,a_{i,n-1})
\quad 0\le i \le m-1
\tag{4-6}
$$
数组一旦被定义，它的维度和维界都不再改变。即只有存取、修改元素的操作。

### 顺序储存

每个元素占L个储存单元,任意一个元素$a_{ij}$的存储位置为
$$
LOC(i,j)=LOC(0,0)+(n\times i+j)L\tag {4-7}
$$
在Basic、Pascal、Java和C语言中，用的都是以行序为主序的存储结构，而在FORTRAN语言中，用的是以列序为主序的存储结构。

n维数组储存位置计算
$$
LOC(j_1,j_2,\cdots,j_n)=LOC(0,0,\cdots ,0)+\sum_{i=1}^n c_ij_i\\
c_n=L,c_{i-1}=b_i\times c_i,1<i\le n\tag{4-8}
$$

### 矩阵压缩

##### 1.对称矩阵

若n阶矩阵A中的元满足下述性质
$$
a_{ij}=a_{ji}\quad 1\le i,j\le n
\tag{4-9}
$$
则称为n阶对称矩阵。

对于对称矩阵，可以为每一对对陈元分配一个存储空间，则可以将$n^2$个元压缩存储到$n(n+1)/2$个元的空间中，不失一般性，可以行序为主序存储其下三角（包括对角线）中的元。

假设以一维数组$sa[n(n+1)/2]$作为$n$阶对称矩阵$A$的存储结构，则$sa[k]$和$a_{ij}$之间存在着一一对应的关系：
$$
k=
\begin{cases}
\frac{i(i-1)}{2}+j-1 &当i\geq j\\
\quad\\
\frac{j(j-1)}{2}+j-1 &当i<j\\
\end{cases}
\tag{4-10}
$$

##### 2.三角矩阵

###### (1)上三角矩阵

$sa[k]$和$a_{ij}$之间存在着一一对应的关系：
$$
k=
\begin{cases}
\frac{i(i-1)(2n-i+2)}{2} &当i\le j\\
\quad\\
\frac{n(n+1)}{2} &当i>j\\
\end{cases}
\tag{4-11}
$$


###### (2)下三角矩阵

$sa[k]$和$a_{ij}$之间存在着一一对应的关系：
$$
k=
\begin{cases}
\frac{i(i-1)}{2}+j-1 &当i\le j\\
\quad\\
\frac{j(j-1)}{2}+j-1 &当i>j\\
\end{cases}
\tag{4-12}
$$

##### 3.对角矩阵

**对角矩阵**所有的非零元都集中在以对角线为主对角线为中心的带状区域中，除此之外其他的元皆为零。也可按某个原则（或以行为主，或以对角线的顺序）将其压缩到一维数组上。

**稀疏矩阵**：其非零元教零元少，且分布没有一定规律。

## 三、广义表

广义表一般记作
$$
LS=(a_1,a_2,\cdots ,a_n)\tag{4-12}
$$

### 例子

1. $A=(\quad)$——$A$是一个空表，其长度为零
2. $B=(e)$——$B$只有一个原子$e$，其长度 为1
3. $C=(a,(b,c,d))$——$C$的长度为2，两个元素分别为原子a和子表$(b,c,d)$
4. $D=(A,B,C)$——$D$的长度为3，3个元素都是广义表。显然，将子表的值代入后，则有$D=((\quad),(e),(a,(b,c,d)))$
5. $E=(a,E)$——这是一个递归的表，其长度为2。$E$相当于一个我要宣布的广义表$E=(a,(a,(a,\cdots)))$

### 结论

（1）广义表的元素可以是子表，子表的元素还可以是子表，广义表可以是一个多层次结构。

（2）广义表可以为其他广义表共享。

（3）广义表可以是一个递归的表，即广义表本身也可以是其本身的一个子表。

### 操作

（1）取表头`GetHead(LS)`：取出的表头为非空广义表的第一个元素（子表或者单原子）。

（2）取表尾`GetTail(LS)`：取出的表尾为除去表头之外，由其余元素构成的表（一定是一个广义表）。

### 存储结构

#### （1）头尾链表的存储结构

```c
//——————广义表的头尾链表存储表示——————
typedef enum{ATOM,LIST} ElemTag;							 //ATOM==0:原子；LIST==1：子表
typedef struct GLNode
{
	ElemTag tag;											 //公共部分，用于区分原子结点和表结点
    union													 //原子结点和表结点的联合部分
    {
		AtomType atom;										 //atom是原子结点的值域，AtomType由用户定义
        struct{struct GLNode *hp,*tp;}ptr;																															 //ptr是表结点的指针域，ptr.hp和ptr.tp分别指向表头																 和表尾
    };
}*GList;													 //广义表类型
```

